[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview: Social Network Analysis (0HV80)",
    "section": "",
    "text": "These notes accompany the social network analysis part of the 0HV80 course and provide an overview of the basic skills needed to network data into informative summaries and visualizations presented in professional reports and presentations. The notes will introduce learners to the R packages igraph and netdiffuseR). The notes will cover importing and processing data from spreadsheets, producing data summaries of the network, creating beautiful and informative visualizations, and simulating network diffusion. In addition to the technical aspects of social network analysis, the notes provide additional theoretical background and mechanisms that help understanding how networks “work”.\nBy the end of these notes, you will be able to use R to:\n\ncreate networks\nimport networks\nclean and process data\ninformatively visualize networks\ncalculate differences in network position\ncalculate cohesion measures\nsimulate network diffusion"
  },
  {
    "objectID": "1.html#a-tutorial-in-r-swirl",
    "href": "1.html#a-tutorial-in-r-swirl",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.1 A tutorial in R: Swirl",
    "text": "2.1 A tutorial in R: Swirl\nI assume that you installed R and RStudio. Open RStudio and type the following into the console.\ninstall.packages(\"swirl\")\nNote that the &gt; symbol at the beginning of the line is R’s prompt for you type something into the console. We include it here so you know that this command is to be typed into the console and not elsewhere. The part you type begins after “&gt;”.\nStarting swirl is the only step that you will repeat every time you want to run swirl. First, you will load the package using the library() function. Then you will call the function that starts the magic! Type the following, pressing Enter (or Ctrl + Enter on my machine) after each line:\nlibrary(\"swirl\")\nswirl()\nThe last step is to install an interactive course, and follow it. The first time you start swirl, you’ll be prompted to install a course. You can either install one of the recommended courses or visit our course repository for more options. There are even more courses available from the Swirl Course Network.\nIf you’d like to install a course that is not part of our course repository, type\n?InstallCourses\nat the R prompt for a list of functions that will help you do so. The best course to start if you are an absolute beginner in R is the very short introduction to R by Claudia Brauer. Run the following code in your R console.\nswirl::install_course(\"A_(very)_short_introduction_to_R\")\nAfter swirl() you can select the course and its modules. Complete the course, and you will have no trouble following the course SNA in R (at least not with the R part!)."
  },
  {
    "objectID": "1.html#defining-network-objects",
    "href": "1.html#defining-network-objects",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.2 Defining network objects",
    "text": "2.2 Defining network objects\nA major advantage of using R for network analysis is the power and flexibility of the tools for accessing and manipulating the actual network data. In this section we will learn how to create network data objects. In a next section we discuss how network from existing data sources can be entered into R and turned into a network data object. Finally, a number of typical network data management tasks are illustrated.\nInstall the latest version of the package “igraph”.\ninstall.packages(\"igraph\")\nNote that igraph should be started via library(igraph) while this is always needed in the remainder, I will not display it in the code as to reduce the output.\n\n2.2.1 the graph command\nThe way that graphs are created, stored and manipulated in R bears a strong resemblance to how they are defined and studied algebraically. A graph \\(G\\) consists of two sets. The first set \\(V\\) is known as the vertex set or node set. The second set \\(E\\) is known as the edge set, and consists of pairs of elements of \\(V\\). Given that a graph is made up of these two sets, we will often notate our graph as \\(G=(V,E)\\). If two vertices appear as a pair in \\(E\\), then those vertices are said to be adjacent or connected vertices.\nLet’s use an example to illustrate this definition. The Figure below is a diagram of a graph \\(G_{HTI}\\) with four vertices representing four professors of our HTI department. An edge connects two vertices if and only if those two people have closely worked together.\n\nG &lt;- graph(edges=c(\"Uwe\",\"Gerrit\",\"Uwe\", \"Rianne\",\"Gerrit\",\"Martijn\",\"Rianne\",\"Martijn\"), directed= F) \n\n# A simple plot of the network - we'll talk more about plots later\nplot(G, asp=0.6) \n\n\n\n\nOur vertex set \\(V\\) for the graph \\(G_{HTI}\\) is is:\n\\(V=\\{Uwe, Gerrit, Rianne, Martijn\\}\\).\nThe edge set is defined as pairs of elements of the vertex set.\n\\(E=\\{\\{Uwe, Gerrit\\},\\{Uwe,Rianne\\},\\{Gerrit,Martijn\\},\\{Rianne,Martijn\\}\\}\\)\nIn the graph command above, we specified that the graph is undirected (“directed=F”). This makes sense obviously, since if Uwe works closely with Gerrit, Gerrit works closely with Uwe. If we do not specify that the graph is undirected, igraph by default assumes that edges are directed (indicating for instance a “x likes y” relationship). As can be verified in the Figure the order of the vertices in the pairs matters.\n\nG &lt;- graph(edges=c(\"Uwe\",\"Gerrit\",\"Uwe\", \"Rianne\",\"Gerrit\",\"Martijn\",\"Rianne\",\"Martijn\")) \nplot(G, asp=0.6) \n\n\n\n\nThere are various ways of creating a network graph in Igraph. The graph command is straightforward. The graph function allows to add isolated vertices. Isolates do not have connections to other vertices, so adding them increases the vertex set, but not the edge set.\n\ng3 &lt;- graph(edges=c(\"Uwe\",\"Gerrit\",\"Uwe\", \"Rianne\",\"Gerrit\",\"Martijn\",\"Rianne\",\"Martijn\"),isolates=c(\"Sanne\", \"Peter\"),  directed= F) \nplot(g3, asp=0.6)\n\n\n\n\nThe graph above is a so-called simple graph since there are no multiple relations between vertices. In a multiple graph this is allowed. An example could be a combination of “x manages y” and “x likes y” relations. Multiple graphs are not common in social network analysis (we will not further discuss them in this course).\n\nmulti_graph &lt;- graph(edges=c(\"Uwe\",\"Gerrit\",\"Uwe\", \"Rianne\", \"Uwe\", \"Rianne\", \"Gerrit\",\"Martijn\",\"Rianne\",\"Martijn\")) \nplot(multi_graph, asp=0.6) \n\n\n\n\nIn a pseudo graph vertices are allowed to connect to themselves (self-loops). This can for instance happen in a “x emails y” network relation, since we can send ourselves an email. In practice (and in our course) self-loops (and pseudo graphs) are not of interest in social network analysis.\n\npseudo_graph &lt;- graph(edges=c(\"Uwe\",\"Uwe\",\"Uwe\",\"Gerrit\",\"Uwe\", \"Rianne\",\"Gerrit\",\"Martijn\",\"Rianne\",\"Martijn\")) \nplot(pseudo_graph, asp=0.6) \n\n\n\n\n\n2.2.2 the graph_from_literal command\nAn somewhat easier alternative to the graph command is the graph_from_literal command. It uses more intuitive symbols for relations: ‘-’ for undirected tie, “+-’ or”-+” for directed ties pointing left & right, “++” for a symmetric tie, and “:” for sets of vertices\n\nplot(graph_from_literal(a---b, b---c), asp=0.6) \n\n\n\nplot(graph_from_literal(a+-+b, b+--c), asp=0.6)\n\n\n\n\nThe ‘:’ operator can be used to define vertex sets. If an edge operator connects two vertex sets then every vertex from the first set will be connected to every vertex in the second set.\n\nplot(graph_from_literal(Alice - Bob:Cecil:Daniel, Cecil:Daniel - Eugene:Gordon))\n\n\n\n\n\n2.2.3 Adding attributes to a graph\nA graph \\(G=(V,E)\\) consists of a vertex set \\(V\\) and an edge set \\(E\\). These sets are the minimum elements of a graph—the vertices represent the entities in the graph and the edges represent the relationships between the entities. We can enhance a graph to provide even richer information on the entities and on the relationships by giving our vertices and edges properties. A vertex property provides more specific information about a vertex and an edge property provides more specific information about the relationship between two vertices.\nWe could for instance include the gender attribute. We can notate properties as additional sets in our graph, ensuring that each entry is in the same order as the respective vertices or edges, as follows:\n\\(V=\\{Uwe, Gerrit, Rianne, Martijn\\}\\).\n\\(V_{gender}=\\{male, male, female, male\\}\\).\nNote that the vertex property set \\(V_{gender}\\) has the same number of elements as \\(V\\) and the associated properties appear in the same order as the vertices of \\(V\\)’. Vertex and edge properties can be added to a new graph at the point of creation or can be added progressively to an existing graph. We will first focus on adding them to an existing graph object in igraph.\n\n# First note that the vertex set can be easily accessed. \nV(G)\n\n+ 4/4 vertices, named, from 2c04b06:\n[1] Uwe     Gerrit  Rianne  Martijn\n\n#Second the names are stored automatically, and can be accessed as well.\nV(G)$name \n\n[1] \"Uwe\"     \"Gerrit\"  \"Rianne\"  \"Martijn\"\n\n\nThe $ operator is used to extract or subset a specific part of a data object in R. For instance, this can be a data frame object or a list. We can use this operator to add a vertex attribute to the igraph object.\n\n# note that the c() function creates a vector .\nV(G)$gender &lt;- c(\"male\", \"male\", \"female\", \"male\")\n\nThe procedure in igraph is similar for edge attributes. Here we include an edge attribute “type of relation”. Again we must make sure that each entry is in the same order as the respective edges:\n\nE(G)\n\n+ 4/4 edges from 2c04b06 (vertex names):\n[1] Uwe   -&gt;Gerrit  Uwe   -&gt;Rianne  Gerrit-&gt;Martijn Rianne-&gt;Martijn\n\nE(G)$type&lt;-c(\"work\",\"personal\", \"work\", \"work\")\nplot(G, edge.label=E(G)$type, asp=0.6)\n\n\n\n\nIn the example above the edges were provided with a categorical label. Edges can have (continuous) weights as well. A well known example are communication networks, where the weight indicates the interaction frequency. Networks where relations have weights are called weighted networks. For instance, suppose that in the \\(G\\) network we are now interested in how often HTI members send emails to each other (monthly).\n\nG &lt;- graph(edges=c(\"Uwe\",\"Gerrit\", \"Gerrit\", \"Uwe\",\"Uwe\", \"Rianne\", \"Rianne\", \"Uwe\", \"Gerrit\",\"Martijn\", \"Martijn\", \"Gerrit\", \"Rianne\",\"Martijn\",\"Martijn\", \"Rianne\")) \nE(G)$weight &lt;- c(16, 11,21,13, 33,2,21, 15) \nplot(G, edge.label=E(G)$weight, asp=0.6)"
  },
  {
    "objectID": "1.html#examing-network-data",
    "href": "1.html#examing-network-data",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.3 Examing network data",
    "text": "2.3 Examing network data\nWhether you import a network (more about that later), or create a network (like above), it is always a good idea to inspect the network and explore whether data entry mistakes or other mistakes were made (just like in normal data analysis practice). When we visually inspect the plot of g3 earlier we can see it has two edges going from Jim to Jack, and a loop from John to himself.\nFor larger networks this is, not always easy to see. An easy command that answers whether there are multiple links between vertices, or self-loops is the is.simple command.\n\nG &lt;- graph(edges=c(\"Uwe\",\"Gerrit\", \"Gerrit\", \"Gerrit\", \"Uwe\", \"Rianne\", \"Uwe\", \"Rianne\", \"Gerrit\",\"Martijn\",\"Rianne\",\"Martijn\"), directed= F) \nplot(G, asp=0.6)\n\n\n\nis.simple(G)\n\n[1] FALSE\n\n\nYou may want to know which relations are multiple or self-loops. Relation number two is the self-loop, and relation number five is the multiple relation.\n\nE(G)\n\n+ 6/6 edges from 2d0bc32 (vertex names):\n[1] Uwe   --Gerrit  Gerrit--Gerrit  Uwe   --Rianne  Uwe   --Rianne \n[5] Gerrit--Martijn Rianne--Martijn\n\nwhich_loop(G)\n\n[1] FALSE  TRUE FALSE FALSE FALSE FALSE\n\nwhich_multiple(G)\n\n[1] FALSE FALSE FALSE  TRUE FALSE FALSE\n\n\nWe can simplify our graph to remove loops & multiple edges between the same nodes using the simplify command (default is that you remove multiple edges and self-loops, but this can be adjusted).\n\nsG&lt;-igraph::simplify(G)\nsG[] #inspect the matrix (dots are zeros)\n\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n        Uwe Gerrit Rianne Martijn\nUwe       .      1      1       .\nGerrit    1      .      .       1\nRianne    1      .      .       1\nMartijn   .      1      1       .\n\n\nYou can inspect the edges and vertices of a network, and inspect the network as a whole or specific rows, columns, or cells as follows:\n\nsG[1,]\n\n    Uwe  Gerrit  Rianne Martijn \n      0       1       1       0 \n\nsG[1,1]\n\n[1] 0\n\nedge_attr(sG)\n\nnamed list()\n\nvertex_attr(sG)\n\n$name\n[1] \"Uwe\"     \"Gerrit\"  \"Rianne\"  \"Martijn\"\n\ngraph_attr(sG)\n\nnamed list()\n\n\nWe will discuss three main ways of entering network data: edgelist data, adjance matrices, and two mode network data."
  },
  {
    "objectID": "1.html#reading-edge-list-data",
    "href": "1.html#reading-edge-list-data",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.4 Reading edge list data",
    "text": "2.4 Reading edge list data\nOne simple way to represent a graph is to list the edges, which we will refer to as an edge list. For each edge, we just list who that edge is incident on. Edge lists are therefore two column matrices that directly tell the computer which actors are tied for each edge. In a directed graph, the actors in column A are the sources of edges, and the actors in Column B receive the tie. In an undirected graph, order doesn’t matter.\nIn R, we can create an example edge list using vectors and data.frames. I specify each column of the edge list with vectors and then assign them as the columns of a data.frame. We can use this to visualize what an edge list should look like.\n\npersonA &lt;- c(\"Mark\", \"Mark\", \"Peter\", \"Peter\", \"Bob\", \"Jill\")\npersonB &lt;- c(\"Peter\", \"Jill\", \"Bob\", \"Aaron\", \"Jill\", \"Aaron\")\n\nedgelist &lt;- data.frame(PersonA = personA, PersonB = personB, stringsAsFactors = F)\n\nprint(edgelist)\n\n  PersonA PersonB\n1    Mark   Peter\n2    Mark    Jill\n3   Peter     Bob\n4   Peter   Aaron\n5     Bob    Jill\n6    Jill   Aaron\n\n\nThere are at least two ways to read edge list data. The example that is shown here use the graph_from_data_frame command. A simpler command graph.edgelist can be used if the data only contains two columns (edges from to).\nThe data set we are using as an example consists of two files, Dataset1-Media-Example- NODES.csv and Dataset1-Media-Example-EDGES.csv\n\nnodes&lt;-read.csv(\"data/Dataset1-Media-Example-NODES.csv\")\nlinks&lt;-read.csv(\"data/Dataset1-Media-Example-EDGES.csv\")\n\nhead(nodes)\n\n\n\n\nid\nmedia\nmedia.type\ntype.label\naudience.size\n\n\n\ns01\nNY Times\n1\nNewspaper\n20\n\n\ns02\nWashington Post\n1\nNewspaper\n25\n\n\ns03\nWall Street Journal\n1\nNewspaper\n30\n\n\ns04\nUSA Today\n1\nNewspaper\n32\n\n\ns05\nLA Times\n1\nNewspaper\n20\n\n\ns06\nNew York Post\n1\nNewspaper\n50\n\n\n\n\n\nhead(links)\n\n\n\n\nfrom\nto\nweight\ntype\n\n\n\ns01\ns02\n10\nhyperlink\n\n\ns01\ns02\n12\nhyperlink\n\n\ns01\ns03\n22\nhyperlink\n\n\ns01\ns04\n21\nhyperlink\n\n\ns04\ns11\n22\nmention\n\n\ns05\ns15\n21\nmention\n\n\n\n\n\n\nNext we will convert the raw data to an igraph network object. To do that, we will use the graph_from_data_frame() function, which takes two data frames: d and vertices.\n• d describes the edges of the network. Its first two columns are the IDs of the source and the target node for each edge. The following columns are edge attributes (weight, type, label, or anything else).\n• vertices starts with a column of node IDs. Any following columns are interpreted as node attributes.\n\nnet &lt;- graph_from_data_frame(d=links, vertices=nodes, directed=T)\nnet\n\nIGRAPH 2e966d8 DNW- 17 52 -- \n+ attr: name (v/c), media (v/c), media.type (v/n), type.label (v/c),\n| audience.size (v/n), weight (e/n), type (e/c)\n+ edges from 2e966d8 (vertex names):\n [1] s01-&gt;s02 s01-&gt;s02 s01-&gt;s03 s01-&gt;s04 s04-&gt;s11 s05-&gt;s15 s06-&gt;s17 s08-&gt;s09\n [9] s08-&gt;s09 s03-&gt;s04 s04-&gt;s03 s01-&gt;s15 s15-&gt;s01 s15-&gt;s01 s16-&gt;s17 s16-&gt;s06\n[17] s06-&gt;s16 s09-&gt;s10 s08-&gt;s07 s07-&gt;s08 s07-&gt;s10 s05-&gt;s02 s02-&gt;s03 s02-&gt;s01\n[25] s03-&gt;s01 s12-&gt;s13 s12-&gt;s14 s14-&gt;s13 s13-&gt;s12 s05-&gt;s09 s02-&gt;s10 s03-&gt;s12\n[33] s04-&gt;s06 s10-&gt;s03 s03-&gt;s10 s04-&gt;s12 s13-&gt;s17 s06-&gt;s06 s14-&gt;s11 s03-&gt;s11\n[41] s12-&gt;s06 s04-&gt;s17 s17-&gt;s04 s08-&gt;s03 s03-&gt;s08 s07-&gt;s14 s15-&gt;s06 s15-&gt;s04\n[49] s05-&gt;s01 s02-&gt;s09 s03-&gt;s05 s07-&gt;s03\n\n\nAbove we already briefly discussed this description. The description of an igraph object starts with four letters:\n\nD or U, for a directed or undirected graph\nN for a named graph (where nodes have a name attribute)\nW for a weighted graph (where edges have a weight attribute)\nB for a bipartite (two-mode) graph (where nodes have a type attribute)\n\nThe two numbers that follow (17 52) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:\n\n(g/c) graph-level character attribute.\n(v/c) vertex-level character attribute. So “name” is a vertex level attribute. The c indicates that this attribute is a character object, which is used to represent string values in R.\n(e/n) edge-level numeric attribute. The “weight” edge attribute refers to how often one media source refers to another (and hence is numerical)\n\nWe have easy access to nodes, edges, and their attributes with the following code.\n\nE(net) # The edges of the \"net\" object\n\n+ 52/52 edges from 2e966d8 (vertex names):\n [1] s01-&gt;s02 s01-&gt;s02 s01-&gt;s03 s01-&gt;s04 s04-&gt;s11 s05-&gt;s15 s06-&gt;s17 s08-&gt;s09\n [9] s08-&gt;s09 s03-&gt;s04 s04-&gt;s03 s01-&gt;s15 s15-&gt;s01 s15-&gt;s01 s16-&gt;s17 s16-&gt;s06\n[17] s06-&gt;s16 s09-&gt;s10 s08-&gt;s07 s07-&gt;s08 s07-&gt;s10 s05-&gt;s02 s02-&gt;s03 s02-&gt;s01\n[25] s03-&gt;s01 s12-&gt;s13 s12-&gt;s14 s14-&gt;s13 s13-&gt;s12 s05-&gt;s09 s02-&gt;s10 s03-&gt;s12\n[33] s04-&gt;s06 s10-&gt;s03 s03-&gt;s10 s04-&gt;s12 s13-&gt;s17 s06-&gt;s06 s14-&gt;s11 s03-&gt;s11\n[41] s12-&gt;s06 s04-&gt;s17 s17-&gt;s04 s08-&gt;s03 s03-&gt;s08 s07-&gt;s14 s15-&gt;s06 s15-&gt;s04\n[49] s05-&gt;s01 s02-&gt;s09 s03-&gt;s05 s07-&gt;s03\n\nV(net) # The vertices of the \"net\" object\n\n+ 17/17 vertices, named, from 2e966d8:\n [1] s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17\n\nE(net)$type # Edge attribute \"type\"\n\n [1] \"hyperlink\" \"hyperlink\" \"hyperlink\" \"hyperlink\" \"mention\"   \"mention\"  \n [7] \"mention\"   \"mention\"   \"mention\"   \"hyperlink\" \"hyperlink\" \"mention\"  \n[13] \"hyperlink\" \"hyperlink\" \"mention\"   \"hyperlink\" \"hyperlink\" \"mention\"  \n[19] \"mention\"   \"mention\"   \"hyperlink\" \"hyperlink\" \"hyperlink\" \"hyperlink\"\n[25] \"hyperlink\" \"hyperlink\" \"mention\"   \"mention\"   \"hyperlink\" \"hyperlink\"\n[31] \"hyperlink\" \"hyperlink\" \"mention\"   \"hyperlink\" \"mention\"   \"hyperlink\"\n[37] \"mention\"   \"hyperlink\" \"mention\"   \"hyperlink\" \"mention\"   \"mention\"  \n[43] \"hyperlink\" \"hyperlink\" \"hyperlink\" \"mention\"   \"hyperlink\" \"hyperlink\"\n[49] \"mention\"   \"hyperlink\" \"hyperlink\" \"mention\"  \n\nV(net)$media # Vertex attribute \"media\"\n\n [1] \"NY Times\"            \"Washington Post\"     \"Wall Street Journal\"\n [4] \"USA Today\"           \"LA Times\"            \"New York Post\"      \n [7] \"CNN\"                 \"MSNBC\"               \"FOX News\"           \n[10] \"ABC\"                 \"BBC\"                 \"Yahoo News\"         \n[13] \"Google News\"         \"Reuters.com\"         \"NYTimes.com\"        \n[16] \"WashingtonPost.com\"  \"AOL.com\"            \n\n\nYou can also find nodes and edges using attribute information. This can be useful when we want to color vertices and edges.\n\nV(net)[media==\"BBC\"]\n\n+ 1/17 vertex, named, from 2e966d8:\n[1] s11\n\nE(net)[type==\"mention\"]\n\n+ 21/52 edges from 2e966d8 (vertex names):\n [1] s04-&gt;s11 s05-&gt;s15 s06-&gt;s17 s08-&gt;s09 s08-&gt;s09 s01-&gt;s15 s16-&gt;s17 s09-&gt;s10\n [9] s08-&gt;s07 s07-&gt;s08 s12-&gt;s14 s14-&gt;s13 s04-&gt;s06 s03-&gt;s10 s13-&gt;s17 s14-&gt;s11\n[17] s12-&gt;s06 s04-&gt;s17 s07-&gt;s14 s05-&gt;s01 s07-&gt;s03\n\n\nSimilar to the analysis of regular data, inspecting and exploring your data to check if there are errors is a must. A first step is to check whether there are multiple relations between vertices or whether there are so-called self-loops, in which case a vertex is connected to itself (which is most often not the case). The is.simple command indicates whether there are multiple relations or self-loops. The which_multiple and `which_loop’ functions return which relations are loops or multiple.\n\nplot(net,vertex.size=8, edge.arrow.size=0.2, asp=0.6)\n\n\n\nis.simple(net)\n\n[1] FALSE\n\nwhich_multiple(net)\n\n [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[13] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE\n\nwhich_loop(net)\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE\n\n\nRemove the multiple edges and self-loops.\n\nnet&lt;-igraph::simplify(net, edge.attr.comb = \"first\")\nplot(net,vertex.size=8, edge.arrow.size=0.2, asp=0.6)\n\n\n\nis.simple(net)\n\n[1] TRUE"
  },
  {
    "objectID": "1.html#reading-adjacency-matrices",
    "href": "1.html#reading-adjacency-matrices",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.5 Reading adjacency matrices",
    "text": "2.5 Reading adjacency matrices\nAdjacency matrices have one row and one column for each actor in the network. The elements of the matrix can be any number but in most networks, will be either 0 or 1. A matrix element of 1 (or greater) signals that the respective column actor and row actor should be tied in the network. Zero signals that they are not tied.\n\nadjacency &lt;- matrix(c(0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0), nrow = 5, ncol = 5, dimnames = list(c(\"Mark\", \"Peter\", \"Bob\", \"Jill\", \"Aaron\"), c(\"Mark\", \"Peter\", \"Bob\", \"Jill\", \"Aaron\")))\n\nprint(adjacency)\n\n      Mark Peter Bob Jill Aaron\nMark     0     1   0    1     0\nPeter    1     0   1    0     1\nBob      0     1   0    1     0\nJill     1     0   1    0     1\nAaron    0     1   0    1     0\n\n\nHere is an example of how to read adjancency matrices. These data are from a well-known series of studies by David Krackhardt of a small company.\n\nInitial.matrix &lt;- read.csv(\"./data/Krack-High-Tec-Advise-edges.csv\", header=TRUE, row.names=1, na.strings = \"\")\nmatrix &lt;- as.matrix(Initial.matrix) \nadvise &lt;- graph.adjacency(matrix, mode=\"directed\", weighted=NULL)\n\nNow we need to add the attribute data to the matrix. First read the information:\n\nnodes &lt;- read.csv(\"./data/Krackh-High-Tec-nodes.csv\", header=T, as.is=T)\n\nAfter reading the data, add it to the advise Igraph object.\n\nV(advise)$age    = nodes$AGE\nV(advise)$tenure = nodes$TENURE\nV(advise)$level  = nodes$LEVEL\n\nNote that the attribute data has managers age (in years), length of service or tenure (in years), level in the corporate hierarchy (coded 1,2 and 3; 1=CEO, 2 = Vice President, 3 = manager)"
  },
  {
    "objectID": "1.html#reading-two-mode-data",
    "href": "1.html#reading-two-mode-data",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.6 Reading two mode data",
    "text": "2.6 Reading two mode data\nTwo-mode or bipartite graphs have two different types of actors and links that go across, but not within each type. Our second media example is a network of that kind, examining links between news sources and their consumers.\n\nnodes2 &lt;- read.csv(\"data/Dataset2-Media-User-Example-NODES.csv\", header=T, as.is=T)\nlinks2 &lt;- read.csv(\"data/Dataset2-Media-User-Example-EDGES.csv\", header=T, row.names=1)\n\nhead(nodes2)\n\n\n\n\nid\nmedia\nmedia.type\nmedia.name\naudience.size\n\n\n\ns01\nNYT\n1\nNewspaper\n20\n\n\ns02\nWaPo\n1\nNewspaper\n25\n\n\ns03\nWSJ\n1\nNewspaper\n30\n\n\ns04\nUSAT\n1\nNewspaper\n32\n\n\ns05\nLATimes\n1\nNewspaper\n20\n\n\ns06\nCNN\n2\nTV\n56\n\n\n\n\n\nhead(links2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nU01\nU02\nU03\nU04\nU05\nU06\nU07\nU08\nU09\nU10\nU11\nU12\nU13\nU14\nU15\nU16\nU17\nU18\nU19\nU20\n\n\n\ns01\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\ns02\n0\n0\n0\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\ns03\n0\n0\n0\n0\n0\n1\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\ns04\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\ns05\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n\n\ns06\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n0\n1\n0\n0\n0\n\n\n\n\n\n\nNote that the matrix “links2” is an adjacency matrix for a two-mode network, also known as an incidence matrix.\n\nnet2 &lt;- graph_from_incidence_matrix(links2)\ntable(V(net2)$type)\n\n\nFALSE  TRUE \n   10    20 \n\n\nWe can also easily generate bipartite projections for the two-mode network: (co-memberships are easy to calculate by multiplying the network matrix by its transposed matrix, or using igraph’s bipartite.projection() function).\n\nnet2.bp &lt;- bipartite.projection(net2)\nnet2.bp\n\n$proj1\nIGRAPH 2f62974 UNW- 10 12 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 2f62974 (vertex names):\n [1] s01--s10 s02--s09 s03--s09 s03--s04 s04--s05 s04--s10 s05--s10 s05--s06\n [9] s06--s07 s06--s08 s07--s08 s08--s09\n\n$proj2\nIGRAPH 2f629c5 UNW- 20 34 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 2f629c5 (vertex names):\n [1] U01--U02 U01--U03 U01--U11 U02--U03 U04--U05 U04--U20 U05--U20 U06--U07\n [9] U06--U08 U06--U09 U06--U19 U06--U20 U07--U08 U07--U09 U08--U09 U09--U10\n[17] U09--U11 U10--U11 U11--U12 U11--U13 U12--U13 U13--U14 U13--U17 U14--U17\n[25] U14--U15 U14--U16 U15--U16 U16--U17 U16--U18 U16--U19 U17--U18 U17--U19\n[33] U18--U19 U19--U20\n\nplot(net2.bp$proj1, vertex.label.color=\"black\", vertex.label.dist=1,\nvertex.size=7, vertex.label=nodes2$media[!is.na(nodes2$media.type)], asp=0.6)\n\n\n\nplot(net2.bp$proj2, vertex.label.color=\"black\", vertex.label.dist=1,\nvertex.size=7, vertex.label=nodes2$media[is.na(nodes2$media.type)], asp=0.6)"
  },
  {
    "objectID": "1.html#selecting-subgraphs",
    "href": "1.html#selecting-subgraphs",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.7 Selecting subgraphs",
    "text": "2.7 Selecting subgraphs\nThe preceding sections covered the basic information needed to create, read and manage network data objects in R. However, the data managements tasks for network analysis do not end there. There are any number of network analytic challenges that will require more sophisticated data management and transformation techniques.\nIn the rest two such examples are covered: preparing subsets of network data for analysis by filtering on node and edge characteristics, and turning directed networks into non-directed networks.\n\n2.7.1 filtering based on node values\nIf a network object contains node characteristics, stored as vertex attributes, this information can be used to select a new subnetwork for analysis. In our example about news above, we have information about the type of media and audience size.\n\nV(net)\n\n+ 17/17 vertices, named, from 2ee6cb2:\n [1] s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17\n\n\nSuppose that we are only interested in relations between newspapers. Using the induced.subgraph command it is easy to select a subset of vertices and their relations. Note that we could als have used other attributes, such as audience size (should we be interested in larger organzations for instance).\n\nnews&lt;-induced.subgraph(net, vids=which(V(net)$media.type==1))\nplot(news,vertex.size=8, vertex.label = V(news)$media, edge.arrow.size=0.2)\n\n\n\nnews\n\nIGRAPH 2fa3c9b DNW- 6 12 -- \n+ attr: name (v/c), media (v/c), media.type (v/n), type.label (v/c),\n| audience.size (v/n), weight (e/n), type (e/c)\n+ edges from 2fa3c9b (vertex names):\n [1] s01-&gt;s02 s01-&gt;s03 s01-&gt;s04 s02-&gt;s01 s02-&gt;s03 s03-&gt;s01 s03-&gt;s04 s03-&gt;s05\n [9] s04-&gt;s03 s04-&gt;s06 s05-&gt;s01 s05-&gt;s02\n\n\nNote that for the plot of the subgraph, we use the attributes of the subgraph as well (not the original)\n\n2.7.2 Filtering Based on Edge Values\nSelecting edges is less common, but can be useful. In Igraph the procedure is a bit different, since the “subgraph.edges” is used. It should include a sequence of edge ids. In the code below first a a vector d is created consisting of logical statements (TRUE if the weight attribute is larger than 10 or else FALSE). The v vector\n\nd=E(net)$weight&gt;10\nd\n\n [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[13] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[25]  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[37]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n\nThe v vector is a count that runs from 1 to the number of edges (which is counted by the ecount command). The vector g contains those edge ids that have a weight larger than 10.\n\nv &lt;- rep(1:ecount(net))\ng&lt;-v[d==TRUE] #is edge &gt; 10\nnet3 &lt;- subgraph.edges(net, g, delete.vertices = TRUE)\nnet3\n\nIGRAPH 2fcf9ee DNW- 17 25 -- \n+ attr: name (v/c), media (v/c), media.type (v/n), type.label (v/c),\n| audience.size (v/n), weight (e/n), type (e/c)\n+ edges from 2fcf9ee (vertex names):\n [1] s01-&gt;s03 s01-&gt;s04 s01-&gt;s15 s02-&gt;s01 s02-&gt;s03 s03-&gt;s01 s03-&gt;s04 s04-&gt;s03\n [9] s04-&gt;s11 s05-&gt;s02 s05-&gt;s15 s06-&gt;s16 s06-&gt;s17 s07-&gt;s08 s07-&gt;s10 s08-&gt;s07\n[17] s08-&gt;s09 s09-&gt;s10 s12-&gt;s13 s12-&gt;s14 s13-&gt;s12 s14-&gt;s13 s15-&gt;s01 s16-&gt;s06\n[25] s16-&gt;s17\n\n\n\n2.7.3 removing isolates\nA common filtering task with networks is to examine the network after removing all the isolates (i.e., nodes with degree of 0).\nTo illustrate we use the first organizational network collected, consisting of observational data on 14 Western Electric (Hawthorne Plant) employees from the bank wiring room first presented in Roethlisberger & Dickson (1939).\nThe employees worked in a single room and include two inspectors (I1 and I3), three solderers (S1, S2 and S3), and nine wiremen or assemblers (W1 to W9). There were five interaction categories, we focus on participation in arguments about open windows.\n\nInitial.matrix &lt;- read.csv(\"data/RDCON.csv\", header=TRUE, row.names=1, check.names=FALSE, na.strings = \"\")\nmatrix &lt;- as.matrix(Initial.matrix) \nRDCON &lt;- graph.adjacency(matrix, mode=\"undirected\", weighted=NULL)\nplot(RDCON, asp=0.6)\n\n\n\n\nThe first method is to simply find all the vertices without a connection (degree = 0), and remove them.\n\nd &lt;- degree(RDCON)\nde &lt;- delete.vertices(RDCON, (d==0)) \n\nThe second method is to first detect the main component (connected subgraph), and select this component. Downside is that there maybe more components that may also be of interest, so use this only in case you are only interested in the main component.\n\nm &lt;- components(RDCON)\nm&lt;-unlist(m$membership)\nMain_component_RDCON &lt;- induced.subgraph(RDCON, vids=which(m==1))"
  },
  {
    "objectID": "1.html#exercise-part-one",
    "href": "1.html#exercise-part-one",
    "title": "\n2  Social computing using R\n",
    "section": "\n2.8 Exercise part one",
    "text": "2.8 Exercise part one\nWe will discuss these exercises in the next meeting, you dont have to hand them in.\n\nCreate a graph of your core network, and plot that network. Include relations between your contacts. You can use abbreviations for the names.\nAdd additional information (age or gender) to the igraph object.\nWhat is the density of your core network? Density captures how many edges there are in a network divided by the total possible number of edges. In an undirected network of size N, there will be (N * (N-1))/2 possible edges. If you think back to the matrix underlying each network, N * N-1 refers to the number of rows (respondents) times the number of columns (respondents again) minus 1 so that the diagonal (i.e. ties to oneself) are excluded. We divide that number by 2 in the case of an undirected network only to account for that fact that the network is symmetrical.\nEnter the “attiro.csv” network into R and create an Igraph object.\nAre there multiple relations and self-loops? If so, Which relations and/or loops?\nAre there isolates? If so, remove this/these isolate(s).\nConsider the following edgelist (MM_edges1.csv) and nodes attributes (MM_Nodes.csv). This network concerns the diffusion of a new mathematics method in the 1950s. The diffusion process was successful since the new method was adopted in a relatively short period by most schools. The example traces the diffusion of the modern math method among school systems which combine elementary and secondary programs in Allegheny County (Pennsylvania, USA). All school superintendents who were at least two years in office were interviewed. They are the gatekeepers to educational innovation because they are in the position to make the final decision. The superintendents were asked to indicate their friendship ties with other superintendents in the county with the following question: Among the chief school administrators in Allegheny County, who are your three best friends? The year of adoption by a superintendent’s school is coded in the partition ModMath_adoption.clu: 1958 is class (time) one, 1959 is class (time) two, etc. Enter the data in R. Plot the network.\nSelect the early adopters (first two years), plot this subgraph."
  },
  {
    "objectID": "2.html#the-vertex-actor-in-the-network",
    "href": "2.html#the-vertex-actor-in-the-network",
    "title": "\n3  Social network basics\n",
    "section": "\n3.1 The vertex / actor in the network",
    "text": "3.1 The vertex / actor in the network\nThe network size (which is often denoted \\(N\\) or in some case \\(g\\)) is the number of vertices, which in a social network are often actors. The vcount function provides the number of vertices in a graph (in addition to asking for information about the graph discussed in previous part). The network size places an upper limit on the number of connections that each individual can have (\\(N-1\\)). For networks of any size, though, few – if any – actors approach this limit. Let’s focus on the number of connections vertices (can) have.\n\n3.1.1 Degree\nA key property of each vertex is its degree, representing the number of links it has to other nodes. The degree can represent the number of friends somebody has, the number of mobile phone contacts an individual has in the call graph (i.e. the number of different individuals the person has talked to), or the number of citations a research paper gets in the citation network.\n\ng1&lt;-graph_from_literal(A--B, A--C, B--C, B--D)\nplot(g1, vertex.color=\"navy\", vertex.size=15,\n     vertex.label.cex=1, vertex.label.dist=3, \n     vertex.label.degree=-pi/2, asp=0.6)\n\n\n\n\nIn the above figure we have: \\(k_{1}=2\\), \\(k_{2}=3\\) \\(k_{3}=2\\),\\(k_{4}=1\\). The total number of links can be expressed as the sum of the node degrees.\n\\(L=\\) \\(\\sum_{k = 1}^{4} k\\) \\(=8\\)\n\ng1&lt;-graph_from_literal(A-+B, A+-C, B+-C, B-+D)\ndegree(g1)\n\nA B C D \n2 3 2 1 \n\nplot(g1, vertex.color=\"navy\", \n     vertex.size=15,\n     vertex.label.cex=1, \n     vertex.label.dist=3, \n     vertex.label.degree=-pi/2, asp=0.6)\n\n\n\n\nThis is a directed network. In directed networks we distinguish between “indegree” (incoming links), and “outdegree” (outgoing links). The outdegree is the sum of the outgoing links (row elements in the adjacency matrix): \\(k_b^{out}= 1\\). The indegree is the sum of the incomping links (the sum of column elements in the adjacency matrix \\(k_b^{in}= 2\\).\n\n3.1.2 Vertex strength\nIn some cases the number of connections of an actor will only provide limited, or maybe even misleading information. For instance suppose that we measure the number of interactions in a communication network. Two actors interacting once will weigh equally as interacting 100 times when calculating the degree.\n\ng2&lt;-graph_from_literal(A--B, A--C, B--C, B--D)\n \nE(g2)$weight=c(1,20,30,100)\n# A simple plot of the network - we'll talk more about plots later\nplot(g2, asp=0.6, edge.label=E(g2)$weight)\n\n\n\n\nIn this case we could opt for the vertex strength measure. This simply sums up the edge weights of the adjacent edges for each vertex.\n\nstrength(g2)\n\n  A   B   C   D \n 21 131  50 100 \n\n\n\n3.1.3 Average degree\nThe average degree is an important property of a network. It simply refers to the average number of links between actors.In the undirected network above the average degree is:\n\\(\\overline{k}=\\) \\(\\frac{1}{N}\\) \\(\\sum_{k = 1}^{N}k =\\) \\(\\frac{2L}{N}\\)\nSo, in a undirected network with four actors, and four edges (like the undirected network above), the average degree is two (since one edge connects two actors twice).\nIn an directed network the average degree is simply the number of Links divided by the number of actors:\n\\(\\overline{k}=\\) \\(\\frac{1}{N}\\) \\(\\sum_{k = 1}^{N}k =\\) \\(\\frac{L}{N}\\)\n\n3.1.4 Degree distribution\nWe can obtain some insight into the structure of a network by looking at the distribution of the degrees. Lets have a look at two social networks: one network consist of relations between households, and was collected in 1948 by American sociologists in a large field study in the Turrialba region, which is a rural area in Costa Rica. The other is a social network data were collected in the Teenage Friends and Lifestyle Study. These are friendship relations between 50 women.\n\n\n\n\n\nWe can easily obtain basic information about the networks. The vcount (nr of vertices), and the ecount (nr of edges) commands can be used to verify the results. Note that you can get the same information about the number of vertices/edges by just typing the name of the network.\n\nmean(degree(friendship))\n\n[1] 4.808511\n\nmean(degree(household))\n\n[1] 5.3\n\nvcount(friendship)\n\n[1] 47\n\necount(friendship)\n\n[1] 113\n\n\nThe degree distribution captures only a small amount of information about a network. But that information still gives important clues into structure of a network.\n\npar(mfrow=c(1,2)) \nd.household =degree(household)\nhist(d.household,col=\"blue\", \n      freq=FALSE, xlab=\"Degree\", ylab=\"density\",\n      main=\"household network\", xlim=c(0,15), ylim=c(0,0.3))\n\nd.friendship =degree(friendship)\nhist(d.friendship,col=\"pink\", xlab=\"Degree\", ylab=\"density\",freq=FALSE,\nmain=\"friendship network\", xlim=c(0,15), ylim=c(0,0.3))\n\n\n\n\nThe average degrees are quite close (5.3 vs 4.8), and the distributions are similar in the sense that most vertices have relatively small degrees. However, there is a clear difference in the sense that the household network has a number of nodes with large degree, they are connected to many other households, and are in network science often referred to as hubs. There are no isolates in the friendship network, most women either have 3 or 4 friends (which aligns with the core network idea of Dunbar, see lecture)."
  },
  {
    "objectID": "2.html#the-dyad",
    "href": "2.html#the-dyad",
    "title": "\n3  Social network basics\n",
    "section": "\n3.2 The dyad",
    "text": "3.2 The dyad\nWe can break large social networks down into their constituent parts. These constituent parts are referred to as “motifs”. The most basic motif consists of two nodes and is called a dyad. Edges in a network signify the presence or absence of dyadic relations. It follows that a dyad in an undirected network can have two unique configurations: connected or disconnected; and three unique configurations in a directed network (mutual, assymetric, and null)\nTo illustrate we use again the first organizational network collected, consisting of observational data on 14 Western Electric (Hawthorne Plant) employees from the bank wiring room first presented in Roethlisberger & Dickson (1939). This time we focus on helping relations (who helps whom).\n\nInitial.matrix &lt;- read.csv(\"data/RDHLP.csv\", header=TRUE, row.names=1, check.names=FALSE, na.strings = \"\")\nmatrix &lt;- as.matrix(Initial.matrix) \nRDHLP &lt;- graph.adjacency(matrix, mode=\"directed\", weighted=NULL)\nplot(RDHLP, asp=0.6)\n\n\n\n\nWe can check the three unique configurations in a directed network (mutual, assymetric, and null) using the dyad_census command.\n\nRDHLP\n\nIGRAPH 390894a DN-- 14 24 -- \n+ attr: name (v/c)\n+ edges from 390894a (vertex names):\n [1] W1-&gt;W3 W1-&gt;W9 W1-&gt;S1 W2-&gt;W3 W2-&gt;W4 W2-&gt;S1 W3-&gt;W2 W4-&gt;W1 W4-&gt;W3 W4-&gt;W6\n[11] W5-&gt;W3 W6-&gt;W3 W6-&gt;W7 W6-&gt;W8 W6-&gt;W9 W7-&gt;S4 W8-&gt;W6 W8-&gt;W7 W8-&gt;W9 W9-&gt;S4\n[21] S1-&gt;W7 S2-&gt;W6 S4-&gt;W4 S4-&gt;W8\n\ndyad_census(RDHLP)\n\n$mut\n[1] 2\n\n$asym\n[1] 20\n\n$null\n[1] 69\n\n\nThere are 24 edges in this network. Since we have 14 vertices, there could have been (14*13) edges (hence the density equals about .13). There are 91 pairs of vertices. Two of them are mutual, which indicates that there are two edges between them. 20 are assymetric, there is only one edge connecting them, and 69 are unconnected.\nThe number of mutual pairs are used to meausre reciprocity in a directed network. Reciprocity is the tendency with which affect, or network ties, sent out by egos are returned by alters. Edges are reciprocal when ego and alter both send each other ties; reciprocity is the graph-level analogue, evaluating the tendency for edges to be reciprocal across the whole network.\nThe default measure of reciprocity in igraph defines the proportion of mutual connections. The total number of connections in RDHLP is 24 (2 * mutual pair + 20 assymetric pairs), the number of reciprocated connections is 4, so 4/24=.17\n\nreciprocity(RDHLP)\n\n[1] 0.1666667\n\ndegree(RDHLP, mode=c(\"out\"))\n\nI1 I3 W1 W2 W3 W4 W5 W6 W7 W8 W9 S1 S2 S4 \n 0  0  3  3  1  3  1  4  1  3  1  1  1  2 \n\n\nOur graph has a reciprocity score of 0.17. Is that high or low? It depends on your expectation, and the context. In this specific case it maybe that there are a number of senior employees helping others that require help, but cannot offer anything in return. Checking the outdegree of RDHLP, lends some support to this idea."
  },
  {
    "objectID": "2.html#the-triad",
    "href": "2.html#the-triad",
    "title": "\n3  Social network basics\n",
    "section": "\n3.3 The triad",
    "text": "3.3 The triad\nTriads consist of three nodes and are therefore more complex than dyads, with more possible arrangements. This becomes clear when you realize an undirected triad consists of three dyads: A and B, B and C, and A and C.\nIn an directed graph, there will be sixteen unique triads (the unique number of motifs in directed graphs is not easily reduced to a functional form).\n\nIn an undirected graph, there are eight possible triads (2^3… sort of obvious given that each dyad can be present or absent and there are three dyads). Of those eight possible triads, four are isomorphic, so that there are four unique triads.\n\n\n3.3.1 The forbidden triad\nTriad number three in the undirected triad census is a so-called transitive triad. A triad involving actors i, j, and k is defined to be transitive if whenever i –&gt; j and j –&gt; k then i –&gt; k. Note that this undirected triads can be transitive or intransitive as well, but this is not important to us in this course.\nThis situation in which the two alters of one ego are also connected to each other is called triadic closure and/or transitivity.\nThis situation occurs frequently in core networks. Around 50% of the triads are closed. These figures, however, underestimate core network density because they only count the strong ties between your friends, such as being friends or “knowing each other well.” If you were to ask instead if your friends merely “know each other,” then you would find ties among your friends to be more common because some of your friends may just know each other but not be friends. Indeed, studies suggest that, when taking this minimum definition of “knowing each other,” the clustering among alters in the core network goes up significantly and studies find a quite consistent density of around 0.75.\nTransitivity tendency. If ego A has ties to alters B and C, then B and C are more likely to be (positively) connected compared with the situation in which ego A has a tie to either B or C (or to neither). In simple language: your connections likely know each other as well. We can measure the transitivity tendency (aka clustering coefficient) in igraph, for this we use the network of 14 Western Electric (Hawthorne Plant) employees from the bank wiring room again. This time we focus on positive relationships (who is friends with whom).\n\nInitial.matrix &lt;- read.csv(\"data/RDPOS.csv\", header=TRUE, row.names=1, check.names=FALSE, na.strings = \"\")\nmatrix &lt;- as.matrix(Initial.matrix) \nRDPOS &lt;- graph.adjacency(matrix, mode=\"undirected\", weighted=NULL)\nplot(RDPOS, asp=0.6)\n\n\n\ntransitivity(RDPOS)\n\n[1] 0.6428571\n\n\nTransitivity measures the probability that the adjacent vertices of a vertex are connected. The .64 tells us that clustering is high, two relations of a worker (provided that the worker has two) are probably related as well.\nHow can we understand that transitivity occurs so often in core networks? How can we explain the fact that your friends also know each other and are often befriended too—even though two random individuals have a minimum chance of knowing each other? There are three mechanisms of social tie-formation that explain the driving forces behind the transitivity tendency in core networks (Granovetter, 1973).\n\nMeeting opportunities social ties are created in contexts of interaction, i.e., there must be an opportunity for persons B and C to meet each other in order to know each other. Because ego A has strong ties to both B and C, it means she often interacts with B and C. This could mean that B and C share the same context as A, such as attending the same school or living in the same neighborhood, and therefore they also know each other. But it could also mean that B and C meet each other because they often interact with ego A (e.g., they are invited by ego A to her parties). Either way, meeting opportunities for B and C are high and one would expect transitivity in core networks.\nStructural balance another mechanism underlying transitivity in core networks is that ego A will be uncomfortable having friends B and C who are not having such positive ties with each other and, in particular, when her friends have a negative relationship. Scholars have argued that this unbalanced situation creates psychological strain for ego A and she will strive towards a balanced network, in which her friends B and C maintain a mutually positive relation.\nHomophily typically people prefer to develop strong ties to others who are like themselves. This means, for example, that friends are chosen because they share the same political or religious views and opinions, or belong to the same ethnic group. For this reason, ego A will probably be quite similar to both B and C. But that also means that B and C are quite similar to one another and therefore they find each other more attractive than a random stranger. In network science researchers commonly use the assortativity coefficient to measure homophily. , this is positive is similar vertices (based on some external property) tend to connect to each, and negative otherwise.\n\n\n# generate a categorical variable indicating what type a worker is.\nworker &lt;- 1:vcount(RDPOS)\nworker[V(RDPOS)$name==\"I1\"|V(RDPOS)$name==\"I3\"]&lt;-1\nworker[V(RDPOS)$name==\"W1\"|V(RDPOS)$name==\"W2\"|V(RDPOS)$name==\"W3\"|V(RDPOS)$name==\"W4\"|V(RDPOS)$name==\"W5\"|V(RDPOS)$name==\"W6\"|V(RDPOS)$name==\"W7\"|V(RDPOS)$name==\"W8\"|V(RDPOS)$name==\"W9\"|V(RDPOS)$name==\"W10\"]&lt;-2\nworker[V(RDPOS)$name==\"S1\"|V(RDPOS)$name==\"S2\"|V(RDPOS)$name==\"S4\"]&lt;-3\nworker\n\n [1] 1 1 2 2 2 2 2 2 2 2 2 3 3 3\n\nassortativity(RDPOS, types1=worker)\n\n[1] -0.1592357\n\n\nThe negative value of the assortativity coefficient indicates that similar type of workers are less likely to have positive relations (although the value is small).\nA similar question is whether similar actors in terms of degree are attracted to each other, which in this network is not the case.\n\nassortativity_degree(RDPOS)\n\n[1] -0.1954023\n\n\n\n3.3.2 Calculating a triad census\nThe triad census calculates how many triads there are of each type (which, as I just mentioned, in a directed network amounts to 16). The interpretation depends on the type of relationship between actors. If we focus on personal relationships, when we see a network with very few complete (003) triads, then we know something about the macro-level structure, just by looking at the frequencies of its constituent parts at the micro-level. By extension, if the whole distribution of triads is very different than the distribution that obtains under a random network, then we hopefully learn something about the macro-level structure that we couldn’t observe just by looking at a visualization of the network.\nigraph has a built in function for the triad census: triad.census(). It takes a network object as an argument and returns the number of each type of triad in the network. As you can see below, it returns 16 different numbers. It uses the M-A-N classification structure: M stands for the number of Mutual ties, A stands for the number of Asymmetric ties, and N stands for the number of Null ties.\nMutual means that ego and alter (say A and B) have a mutual relation with each other (A likes B and B likes A). A means that ego and alter have an asymmetric relation with one another, i.e. A likes B but B doesn’t like A… the relation is not reciprocated. Finally, N means that A and B do not have any relation.\n003 for example means there are 0 mutual relation, 0 asymmetric relations and 3 null relations. This triad contains no relations. 201 would mean there are two mutual relations, zero asymmetric relations, and 1 null relation. Of three dyads in the triad, two dyads are in a relation, and one dyad is not.\n\n003 = A,B,C, the empty subgraph.\n012 = A-&gt;B, C, subgraph with a single directed edge.\n102 = A&lt;-&gt;B, C, the subgraph with a mutual connection between two vertices.\n021D = A&lt;-B-&gt;C, the out-star.\n021U = A-&gt;B&lt;-C, the in-star.\n021C = A-&gt;B-&gt;C, directed line.\n111D = A&lt;-&gt;B&lt;-C.\n111U = A&lt;-&gt;B-&gt;C.\n030T = A-&gt;B&lt;-C, A-&gt;C.\n030C = A&lt;-B&lt;-C, A-&gt;C.\n201 = A&lt;-&gt;B&lt;-&gt;C.\n120D = A&lt;-B-&gt;C, A&lt;-&gt;C.\n120U = A-&gt;B&lt;-C, A&lt;-&gt;C.\n120C = A-&gt;B-&gt;C, A&lt;-&gt;C.\n210 = A-&gt;B&lt;-&gt;C, A&lt;-&gt;C.\n300 = A&lt;-&gt;B&lt;-&gt;C, A&lt;-&gt;C, complete subgraph.\n\n?triad.census also describes these possible types, telling you the order that the triad types are presented in the triad.census() output."
  },
  {
    "objectID": "2.html#distance-in-social-networks",
    "href": "2.html#distance-in-social-networks",
    "title": "\n3  Social network basics\n",
    "section": "\n3.4 Distance in social networks",
    "text": "3.4 Distance in social networks\nThe way people are embedded in networks can be complex. Two persons, call them A and B, might each have five friends. But suppose that none of person A’s friends have any friends except A. Person B’s five friends, in contrast, each have five friends. The information available to B, and B’s potential for influence is far greater than A’s. That is, sometimes being a “friend of a friend” may be quite consequential.\nTo capture this aspect of how individuals are embedded in networks, one main approach is to examine the distance that an actor is from others. If two actors are adjacent, the distance between them is one (that is, it takes one step for a signal to go from the source to the receiver). If A tells B, and B tells C (and A does not tell C), then actors A and C are at a distance of two. How many actors are at various distances from each actor can be important for understanding the differences among actors in the constraints and opportunities they have as a result of their position. Sometimes we are also interested in how many ways there are to connect between two actors, at a given distance. That is, can actor A reach actor B in more than one way? Sometimes multiple connections may indicate a stronger connection between two actors than a single connection.\nThe distances among actors in a network may be an important macro-characteristic of the network as a whole. Where distances are great, it may take a long time for information to diffuse across a population. It may also be that some actors are quite unaware of, and influenced by others – even if they are technically reachable, the costs may be too high to conduct exchanges. The variability across the actors in the distances that they have from other actors may be a basis for differentiation and even stratification. Those actors who are closer to more others may be able to exert more power than those who are more distant. We will have a good deal more to say about this aspect of variability in actor distances in the next chapter.\nFor the moment, we need to learn a bit of jargon that is used to describe the distances between actors: walks, paths, semi-paths, etc. Using these basic definitions, we can then develop some more powerful ways of describing various aspects of the distances among actors in a network.\nTo describe the distances between actors in a network with precision, we need some terminology. And, as it turns out, whether we are talking about a simple graph or a directed graph makes a good bit of difference. If A and B are adjacent in a simple graph, they have a distance of one. In a directed graph, however, A can be adjacent to B while B is not adjacent to A – the distance from A to B is one, but there is no distance from B to A. Because of this difference, we need slightly different terms to describe distances between actors in graphs and digraphs.\n\n3.4.1 walks\nThe most general form of connection between two actors in a simple graph (a graph without multiple edges, and self-loops) is called a walk. A walk is a sequence of actors and relations that begins and ends with actors. A closed walk is one where the beginning and end point of the walk are the same actor. Walks are unrestricted. A walk can involve the same actor or the same relation multiple times. A cycle is a specially restricted walk that is often used in algorithms examining the neighborhoods (the points adjacent) of actors. A cycle is a closed walk of 3 or more actors, all of whom are distinct, except for the origin/destination actor. The length of a walk is simply the number of relations contained in it. For example,\n\n\n\n\n\nThere are many, most often even infinite, walks in a graph. To illustrate just a few, begin at actor A and go to actor C. There is one walk of length 2 (A,B,C). There is one walk of length three (A,B,D,C). There are several walks of length four (A,B,E,D,C; A,B,D,B,C; A,B,E,B,C). Because these are unrestricted, the same actors and relations can be used more than once in a given walk. There are no cycles beginning and ending with A. There are some beginning and ending with actor B (B,D,C,B; B,E,D,B; B,C,D,E,B).\n\n3.4.2 trails\nIt is usually more useful to restrict our notion of what constitutes a connection somewhat. One possibility is to restrict the count only walks that do not re-use relations. A trail between two actors is any walk that includes a given relation no more than once (the same other actors, however, can be part of a trail multiple times. The length of a trail is the number of relations in it. All trails are walks, but not all walks are trails. If the trail begins and ends with the same actor, it is called a closed trail. In our example above, there are a number of trails from A to C. Excluded are tracings like A,B,D,B,C (which is a walk, but is not a trail because the relation BD is used more than once).\n\n3.4.3 paths\nPerhaps the most useful definition of a connection between two actors (or between an actor and themself) is a path. A path is a walk in which each other actor and each other relation in the graph may be used at most one time. The single exception to this is a closed path, which begins and ends with the same actor. All paths are trails and walks, but all walks and all trails are not paths. In our example, there are a limited number of paths connecting A and C: A,B,C; A,B,D,C; A,B,E,D,C.\n\n3.4.4 walks and paths in directed graphs\nWalks, trails and paths can also be defined for directed graphs. One option is to disregard the direction of edges. Semi-walks, semi-trails, and semi-paths are the same as for undirected data. In defining these distances, the directionality of connections is simply ignored (that is, arcs - or directed ties are treated as though they were edges - undirected ties). As always, the length of these distances is the number of relations in the walk, trail, or path.\n\n\n\n\n\nIf we do want to pay attention to the directionality of the connections we can define walks, trails, and paths in the same way as before, but with the restriction that we may not “change direction” as we move across relations from actor to actor.\n\n3.4.5 geodesic distance\nOne particular definition of the distance between actors in a network is used by most algorithms to define more complex properties of individual’s positions and the structure of the network as a whole. This quantity is the geodesic distance. For both directed and undirected data, the geodesic distance is the number of relations in the shortest possible walk from one actor to another (or, from an actor to themselves, if we care, which we usually do not).\nThe geodesic distance is widely used in network analysis. There may be many connections between two actors in a network. If we consider how the relation between two actors may provide each with opportunity and constraint, it may well be the case that not all of these ties matter. For example, suppose that I am trying to send a message to Mia. Since I know her e-mail address, I can send it directly (a path of length 1). I also know Jill, and I know that Jill has Amy’s email address. I could send my message for Mia to Jill, and ask her to forward it. This would be a path of length two. Confronted with this choice, I am likely to choose the geodesic path (i.e. directly to Mia) because it is less trouble and faster, and because it does not depend on Jill.\nThat is, the geodesic path (or paths, as there can be more than one) is often the “shortest” or most “efficient” connection between two actors. Many algorithms in network analysis assume that actors will use the geodesic path when alternatives are available.\nIn the network below the geodesic distance between Amy and Mia is three. \\(Amy \\to Eva \\to Jill \\to Mia\\).\n\n\n\n\n\n\n3.4.6 calculating distances\nBecause the network above is small, the geodesic distances are generally small. This suggests that information may travel pretty quickly in this network. Also note that there is a geodesic distance for each x, y and y, x pair – that is, the graph is fully connected, and all actors are “reachable” from all others (that is, there exists a path of some length from each actor to each other actor).\nBecause the current network is fully connected, a message that starts anywhere will eventually reach everyone. Although the computer has not calculated it, we might want to calculate the mean (or median) geodesic distance (aka average path length), and the standard deviation in geodesic distances for the matrix, and for each actor row-wise and column-wise. This would tell us how far each actor is from each other as a source of information for the other; and how far each actor is from each other actor who may be trying to influence them. It also tells us which actors behavior (in this case, whether they’ve heard something or not) is most predictable and least predictable.\n\ndistances(n)\n\n     Mia Jill Ivy Ada Eva Amy Gina\nMia    0    1   2   2   2   3    3\nJill   1    0   1   1   1   2    2\nIvy    2    1   0   2   2   3    3\nAda    2    1   2   0   1   2    1\nEva    2    1   2   1   0   1    1\nAmy    3    2   3   2   1   0    2\nGina   3    2   3   1   1   2    0\n\n\nIn looking at the whole network, we see that it is connected, and that the average geodesic distance among actors is quite small. This suggests a system in which information is likely to reach everyone, and to do so fairly quickly. To get another notion of the size of a network, we might think about its diameter. The diameter of a network is the largest geodesic distance in the (connected) network. In the current case, no actor is more than three steps from any other – a very “compact” network. The diameter of a network tells us how “big” it is, in one sense (that is, how many steps are necessary to get from one side of it to the other). The diameter is also a useful quantity in that it can be used to set an upper bound on the lengths of connections that we study. Many researchers limit their explorations of the connections among actors to involve connections that are no longer than the diameter of the network.\nThe average path length for this fully connected graph is easily calculated in R. For each actor, that actor’s largest geodesic distance is called the eccentricity – a measure of how far a actor is from the furthest other. For Gina this is three (Ada).\n\nmean_distance(b, directed=F)\n\n[1] 1.4\n\n\nWhen a network is not fully connected, we cannot exactly define the geodesic distances among all pairs.\n\nni  &lt;- graph(c(\"Mia\",\"Jill\",\n              \"Jill\",\"Ivy\",\n              \"Jill\",\"Ada\",\n              \"Jill\",\"Eva\",\n              \"Eva\",\"Ada\",\n              \"Eva\",\"Amy\",\n              \"Eva\",\"Gina\",\n              \"Ada\",\"Gina\"), isolates=c(\"Jen\"), directed = F)\nlay = layout.fruchterman.reingold(ni)\nplot(ni, vertex.size=25, layout = lay, asp=0.6)\n\n\n\ndistances(ni)\n\n     Mia Jill Ivy Ada Eva Amy Gina Jen\nMia    0    1   2   2   2   3    3 Inf\nJill   1    0   1   1   1   2    2 Inf\nIvy    2    1   0   2   2   3    3 Inf\nAda    2    1   2   0   1   2    1 Inf\nEva    2    1   2   1   0   1    1 Inf\nAmy    3    2   3   2   1   0    2 Inf\nGina   3    2   3   1   1   2    0 Inf\nJen  Inf  Inf Inf Inf Inf Inf  Inf   0\n\n\nThis poses a problem if we want to calculate the average path length. The current standard approach is to calculate the averages for all the different components (connects subsets more about this later). In some approaches the geodesic distance between unconnected actors was defined as a length greater than that of any real distance in the data.\n\nmean_distance(ni,directed = FALSE, unconnected = FALSE)\n\n[1] Inf"
  },
  {
    "objectID": "2.html#real-versus-random-networks",
    "href": "2.html#real-versus-random-networks",
    "title": "\n3  Social network basics\n",
    "section": "\n3.5 Real versus random networks",
    "text": "3.5 Real versus random networks\nHuman networks differ from random networks. Scientific models are simplified descriptions of the real world that are used to predict or explain the characteristics or behavior of the phenomenon of interest. Models can be used in network science in the same way. With network models we can move beyond simple description to build and test hypotheses about network structures, formation processes, and network dynamics In this chapter, a number of basic mathematical models of network structure and formation are covered. These are important models in the history of network science, but they are still useful today to provide insight into fundamental properties of social networks, to serve as baseline or comparison models for empirical social networks, and to act as building blocks for more complex network simulations.Well over a dozen functions are provided in igraph for generating random networks based on a number of mathematical algorithms and heuristics. These all use ‘game’ as the final part of the function name, for example barabasi.game() produces scale-free random graphs based on the Baraba´si-Albert model (1999). We will discuss three important mathematical network models available in igraph.\n\n3.5.1 The Erdos and Renyi model\nThe earliest historically, and still one of the most important mathematical models of network structure, is the random graph model first developed by Paul Erdos and Alfred Renyi in the late 1950s and early 1960s (Newman 2010). This is sometimes called the Poisson random graph model (because of the Poisson degree distribution of large random graphs), or sometimes even just the random graph model. The model is quite simple, G(n,m), where a random graph G is defined with n vertices and m edges among those vertices chosen randomly. An equivalent model that is easier to work with is G(n, p), where instead of specifying m edges, each edge appears in the graph with probability p. This random graph model is implemented in igraph with the erdos.reny.game() function. A random graph is produced by specifying the size of the desired network, and either the number of edges, or the probability of observing an edge. The type argument is used to specify whether the second argument should be interpreted as probability of an edge p, or number of edges m.\n\ng1 &lt;- sample_gnm(n=12,10)\ng2 &lt;- sample_gnm(n=12,10)\n\nop &lt;- par(mar=c(0,1,3,1),mfrow=c(1,2))\nplot(g1,vertex.color=2, main=\"First random graph\")\nplot(g2,vertex.color=4, main=\"Second random graph\")\n\n\n\npar(op)\n\nDespite the simplicity of the random graph model, it has led to a number of important discoveries about network structures. First, for large n the network will have a Poisson degree distribution.\n\ng &lt;- sample_gnp(n=1000,.005)\nplot(degree.distribution(g),\ntype=\"b\",xlab=\"Degree\",ylab=\"Proportion\")\n\n\n\n\nIt turns out that random graphs become entirely connected for fairly low values of average degree. That means even when edges are determined randomly, each individual network member does not have to be connected to too many other members for the network itself to be connected (i.e., the network has only one component). More precisely, if p is greater than \\(ln{(n)}/n\\), then the random graph is likely to be connected in one large component (Newman 2010). The average degree of a random graph, \\(c\\), is related to graph size and edge probability: \\(c = (n−1)p\\). So this means that across the range of network sizes often seen in social network analysis (say, 100–10,000), the average degree required to have a completely connected network will be less than approximately 12. The following random graph simulation and plot demonstrates this relationship.\n\n\n\n\n\nAnother surprising property of random graphs is that the connected random graphs are quite compact. That is, the diameter of the largest components in random graphs stays relatively small even for large networks.\n\n3.5.2 Small world models\nThe Erdos-Renyi random graph model has one major limitation in that it does not describe the properties of many real-world social networks. In particular, fully random graphs have degree distributions that do not match observed networks very well, and they also have quite low levels of clustering (transitivity).One type of model, called the small-world model by Watts and Strogatz (1998), produces random networks that are somewhat more realistic than Erdos-Renyi.\nThe small-world model starts with a circle of nodes, where each node is connected to its c immediate neighbors (forming a formal lattice structure). Then, a small number of existing edges are rewired, where they are removed and then replaced with another tie that connects two random nodes. If the rewiring probability is 0, then we end up with the original lattice network. When p is 1, then we have an Erdos-Renyi random graph. The main interesting discovery of Watts and Strogatz who created the model, is that only a small fraction of ties needs to be rewired to dramatically reduce the diameter of the network.\nThis figure shows how various small-world model networks look with different rewiring probabilities. The watts.strogatz.game() is called to produce a small-world network of 30 nodes. Setting the option nei=2 (for neighborhood) will start the network with each node tied to the closest two neighbors on either side. This results in each node having degree=4.\n\ng1 &lt;- sample_smallworld(dim=1, size=30, nei=2, p=0)\ng2 &lt;- sample_smallworld(dim=1, size=30, nei=2, p=.05)\ng3 &lt;- sample_smallworld(dim=1, size=30, nei=2, p=.20)\ng4 &lt;- sample_smallworld(dim=1, size=30, nei=2, p=1)\nop &lt;- par(mar=c(2,1,3,1),mfrow=c(2,2))\nplot(g1,vertex.label=NA,layout=layout_with_kk,\n     main=expression(paste(italic(p),\" = 0\")))\nplot(g2,vertex.label=NA,\n     main=expression(paste(italic(p),\" = .05\")))\nplot(g3,vertex.label=NA,\n     main=expression(paste(italic(p),\" = .20\")))\nplot(g4,vertex.label=NA,\n     main=expression(paste(italic(p),\" = 1\")))\n\n\n\n\nThe following simulation and figure shows how quickly rewiring reduces the diameter of a network in the small-world model. Working with a network with 100 nodes, each node starts out connected to its two neighbors on each side. The graph will thus have 200 edges. The starting diameter of the lattice network is 25 (getting from one node to the other side of the circle takes 25 steps).\n\ng100 &lt;- sample_smallworld(dim=1,size=100,nei=2,p=0)\ng100\n\nIGRAPH 3b225dc U--- 100 200 -- Watts-Strogatz random graph\n+ attr: name (g/c), dim (g/n), size (g/n), nei (g/n), p (g/n), loops\n| (g/l), multiple (g/l)\n+ edges from 3b225dc:\n [1]  1-- 2  2-- 3  3-- 4  4-- 5  5-- 6  6-- 7  7-- 8  8-- 9  9--10 10--11\n[11] 11--12 12--13 13--14 14--15 15--16 16--17 17--18 18--19 19--20 20--21\n[21] 21--22 22--23 23--24 24--25 25--26 26--27 27--28 28--29 29--30 30--31\n[31] 31--32 32--33 33--34 34--35 35--36 36--37 37--38 38--39 39--40 40--41\n[41] 41--42 42--43 43--44 44--45 45--46 46--47 47--48 48--49 49--50 50--51\n[51] 51--52 52--53 53--54 54--55 55--56 56--57 57--58 58--59 59--60 60--61\n[61] 61--62 62--63 63--64 64--65 65--66 66--67 67--68 68--69 69--70 70--71\n+ ... omitted several edges\n\ndiameter(g100)\n\n[1] 25\n\n\nThe simulation is set to calculate 300 networks, ten each for the number of edges to rewire ranging from 1 to 30. Because we know how many edges are in each graph (200), the rewiring probability can be calculated by the number of rewired edges divided by total number of edges. If 30 edges are rewired, then, the probability is 0.15.\n\n\n\n\n\nThe plot demonstrates that after only rewiring ten of the edges (p=0.05), the diameter has shrunk at least 60%, from 25 to about 10.\n\n3.5.3 Scale free models\nAn important limitation of the previous two mathematical network models is that they produce graphs with degree distributions that are not representative of many.real-world social networks. Numerous studies, in fact, have shown that a wide variety of observed networks have heavy-tailed degree distributions that approximately follow a “power law”. These are typically called scale-free networks. For example, both the network of sexual partners and the World-Wide-Web exhibit this scale-free pattern. That is, some people have many sexual partners (high degree), but most people have a small number of sexual partners.Similarly, some websites have a very large number of other websites connected to them, but most websites have only a few connections. How does this power-law characteristic feature of scale-free social networks arise? A number of network scientists have explored this question, and have determined that a network formation process of cumulative advantage, or preferential attachment can explain this. That is, as networks grow, new nodes are more likely to form ties with other nodes that already have many ties, due to their visibility in the network. This ‘rich-gets-richer’ phenomena has been shown to lead to the powerlaw distribution in networks.\nThe preferential attachment model of Barabasi and Albert is implemented in igraph with the barabasi.game() function. This is a more complicated algorithm than those for the previous models, partly because this is a network growth model, not just a static network structure model.\nThe figure below displays a 500-node network that is formed with this preferential attachment model. The default behavior of the algorithm is that as each new node is added to the network, it is connected to another node in the network, with probability proportional to the degree of that node. Thus, some nodes in the network will end up with many more ties than most of the other nodes. Note that sample_pa command is equivalent, it contains many options to complicate the model not shown here.\n\ng &lt;- sample_pa(500, directed = FALSE)\nV(g)$color &lt;- \"lightblue\"\nV(g)[degree(g) &gt; 9]$color &lt;- \"red\"\nplot(g, vertex.label = NA, vertex.size = degree(g))"
  },
  {
    "objectID": "2.html#exercise",
    "href": "2.html#exercise",
    "title": "\n3  Social network basics\n",
    "section": "\n3.6 Exercise",
    "text": "3.6 Exercise\nIn the 1950s John Gagnon collected sociometric choice data from 67 prison inmates. All were asked, “What fellows on the tier are you closest friends with?” Each was free to choose as few or as many “friends” as he desired. The data were analyzed by MacRae and characterized by him as “less clear cut” in their internal structure than similar data from schools or residential populations.\n\nRead the data and transform them into an igraph object. Then think about how many friends an inmate will have, and test your hypothesis. Assume that both an incoming nomination and outgoing nomination indicate a friendship relation.\nWho is the most popular inmate?\nAre more popular inmates also inclined to nominate more others as friends (so in a way are the more agreeable)\nTo what degree are friendship nominations reciprocated?\nCalculate the triad census and interpret the outcome.\nAssuming that a nomination indicates a friendship, what is the diameter of the network, what is the average path length? How clustered is the network?\nCompare the prison network to a random network (ER model with the same nr of vertices and edges)"
  },
  {
    "objectID": "3.html#visualization",
    "href": "3.html#visualization",
    "title": "\n4  Inequality and network position\n",
    "section": "\n4.1 Visualization",
    "text": "4.1 Visualization\nProducing and examining a network plot is often one of the first steps in network analysis. The overall purpose of a network graphic (as with any information graphic) is to highlight the important information contained in the underlying data. However, there are innumerable ways to visually layout network nodes and ties in two-dimensional space, as well as using graphical elements (e.g.,node size, line color, figure legend, etc.) to communicate the story in the network data. In the next three chapters we go over basic principles of effective network graph design, and how to produce effective network visualizations in R. The purpose of this part is to introduce basic plotting techniques for networks in R, and discuss the various options for specifying the layout of the network on the screen or page. The following example shows how interpretation of a network graphic can be impeded or enhanced by its basic layout.\nNetwork plots in igraph have a wide set of parameters you can set. We will discuss most below, but you can also check out ?igraph.plotting for more information.\nIf you plan on using the built-in color names, here’s how to list all of them: colors()\n\n4.1.1 The data: Zachary’s karate-club\nTo illustrate we’ll use the famous Zachary’s Karate-club data (you can obtain it via the igraphdata package). This graph originates from a piece of research on a karate club by social anthropologist Wayne W. Zachary, and is commonly used as an example of a social network in many teaching situations today. The graph contains 34 vertices representing different individuals or actors. The karate instructor is labelled as ‘Mr Hi’. The club administrator is labelled as ‘John A’. The other 32 actors are labelled as ‘Actor 2’ through ‘Actor 33’. Zachary studied the social interactions between the members outside the club meetings, and during his study a conflict arose in the club that eventually led to the group splitting into two: one group forming a new club around the instructor Mr Hi and the other group dispersing to find new clubs or to give up karate completely. In this graph, an edge between two vertices means that the two individuals interacted socially outside the club.\n\ndata(karate)\nhead(karate)\n\nThis graph was created by an old(er) igraph version.\n  Call upgrade_graph() on it to use with the current igraph version\n  For now we convert it on the fly...\n\n\n6 x 34 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 34 column names 'Mr Hi', 'Actor 2', 'Actor 3' ... ]]\n\n\n                                                                           \nMr Hi   . 4 5 3 3 3 3 2 2 . 2 3 1 3 . . . 2 . 2 . 2 . . . . . . . . . 2 . .\nActor 2 4 . 6 3 . . . 4 . . . . . 5 . . . 1 . 2 . 2 . . . . . . . . 2 . . .\nActor 3 5 6 . 3 . . . 4 5 1 . . . 3 . . . . . . . . . . . . . 2 2 . . . 2 .\nActor 4 3 3 3 . . . . 3 . . . . 3 3 . . . . . . . . . . . . . . . . . . . .\nActor 5 3 . . . . . 2 . . . 3 . . . . . . . . . . . . . . . . . . . . . . .\nActor 6 3 . . . . . 5 . . . 3 . . . . . 3 . . . . . . . . . . . . . . . . .\n\n\nAs we have seen in previous parts of the course the igraph package allows for simple plotting of graphs using the plot() function. The function works instantly with an igraph object, using default values for its various arguments. As a starting point, we will use all of the default values except for the layout of the graph. We will set the layout of the plot initially to be a random layout, which will randomly allocate the vertices to different positions.\n\n# set seed for reproducibility\nset.seed(123)\n\n# create random layout\nl &lt;- layout_randomly(karate)\n\n# plot with random layout\nplot(karate, layout = l)\n\n\n\n\nLooking at the Figure we note that the labeling of the vertices is somewhat obtrusive and unhelpful to the clarity of the graph. This will be a common problem with default graph plotting, and with a large number of vertices the plot can easily turn into a messy cloud of overlapping labels.\n\n4.1.2 Adjusting vertices\nVertex labels can be adjusted via properties of the vertices. The most common properties adjusted are as follows:\n\n\nlabel: The text of the label\n\nlabel.family: The font family to be used (default is ‘serif’)\n\nlabel.font: The font style, where 1 is plain (default), 2 is bold, 3 is italic, 4 is bold and italic and 5 is symbol font\n\nlabel.cex: The size of the label text\n\nlabel.color: The color of the label text\n\nlabel.dist: The distance of the label from the vertex, where 0 is centered on the vertex (default) and 1 is beside the vertex\n\nlabel.degree: The angle at which the label will display relative to the center of the vertex, in radians. The default is -pi/4\n\nLet’s try to change the vertex labels so that they only display for Mr Hi and for John A. Let’s also change the size, color and font family of the labels.\n\n# only store a label if Mr Hi or John A\n# %in%: A logical vector, indicating if a match was located for each element of \n# V(karate)$name\n\nV(karate)$label &lt;- ifelse(V(karate)$name %in% c(\"Mr Hi\", \"John A\"),\n                          V(karate)$name,\n                          \"\")\n\n# change label font color, size and font family \n# (selected font family needs to be installed on system)\nV(karate)$label.color &lt;- \"black\"\nV(karate)$label.cex &lt;- 0.8\n\nplot(karate, layout = l)\n\n\n\n\nNow that we have cleaned up the label situation, we may wish to change the appearance of the vertices. Here are the most commonly used vertex properties which allow this:\n\n\nsize: The size of the vertex\n\ncolor: The fill color of the vertex\n\nframe.color: The border color of the vertex\n\nshape: The shape of the vertex; multiple shape options are supported including circle, square, rectangle and none\n\n\n# different colors and shapes for Mr Hi and and John A\nV(karate)$color &lt;- ifelse(V(karate)$name %in% c(\"Mr Hi\", \"John A\"),\n                          \"lightblue\", \n                          \"orange\")\n\nV(karate)$shape &lt;- ifelse(V(karate)$name %in% c(\"Mr Hi\", \"John A\"),\n                          \"square\", \n                          \"circle\")\n\n\nplot(karate, layout = l)\n\n\n\n\n\n4.1.3 Adjusting edges\nIn a similar way, edges can be changed through adding or editing edge properties. Here are some common edge properties that are used to change the edges in an igraph plot:\n\n\ncolor: The color of the edge\n\nwidth: The width of the edge\n\narrow.size: The size of the arrow in a directed edge\n\narrow.width: The width of the arrow in a directed edge\n\narrow.mode: Whether edges should direct forward (&gt;), backward (&lt;) or both (&lt;&gt;)\n\nlty : Line type of edges, with numerous options including solid, dashed, dotted, dotdash and blank\n\ncurved: The amount of curvature to apply to the edge, with zero (default) as a straight edge, negative numbers bending clockwise and positive bending anti-clockwise\n\nNote that edges, like vertices, can also have a label property and various label settings like label.cex and label.family. Let’s adjust our karate graph to have blue dashed edges, with the result in Figure 3.5.\n\n# change color and linetype of all edges\nE(karate)$color &lt;- \"blue\"\nE(karate)$lty &lt;- \"dashed\"\n\nplot(karate, layout = l)\n\n\n\n\n\n4.1.4 Network layouts\nThe layout of a graph determines the precise position of its vertices on a 2-dimensional plane or in 3-dimensional space. Layouts are themselves algorithms that calculate vertex positions based on properties of the graph. Different layouts work for different purposes, for example to visually identify communities in a graph, or just to make the graph look pleasant. We preciously used a random layout for our karate graph. Now let’s look at common alternative layouts. Layouts are used by multiple plotting packages, but we will explore them using igraph base plotting capabilities here.\nThere are two ways to add a layout to a graph in igraph. If you want to keep the graph object separate from the layout, you can create the layout and use it as an argument in the plot() function. Alternatively, you can assign a layout to a graph object by making it a property of the graph. You should only do this if you intend to stick permanently with your chosen layout and do not intend to experiment. You can use the add_layout_() function to achieve this. For example, this would create a karate graph with a grid layout.\n\n#check whether existing karate graph has a layout property\nkarate$layout\n\nNULL\n\n\n\n# assign grid layout as a graph property\nset.seed(123)\nkarate_grid &lt;- igraph::add_layout_(karate, on_grid())\n\n# check a few lines of the 'layout' property\nhead(karate_grid$layout)\n\n     [,1] [,2]\n[1,]    0    0\n[2,]    1    0\n[3,]    2    0\n[4,]    3    0\n[5,]    4    0\n[6,]    5    0\n\n\nWe can see that our new graph object has a layout property. Note that running add_layout_() on a graph that already has a layout property will by default overwrite the previous layout unless you set the argument overwrite = FALSE.\nAs well as the random layout demonstrated in Figure 3.2, common shape layouts include as_star(), as_tree(), in_circle(), on_grid() and on_sphere().\n\n# circle layout\nset.seed(123)\ncirc &lt;- layout_in_circle(karate)\nplot(karate, layout = circ)\n\n\n\n\n\n# sphere layout\nset.seed(123)\nsph &lt;- layout_on_sphere(karate)\nplot(karate, layout = sph)\n\n\n\n\nForce-directed graph layouts are extremely popular, as they are aesthetically pleasing and they help visualize communities of vertices quite effectively, especially in graphs with low to moderate edge complexity. These algorithms emulate physical models like Hooke’s law to attract connected vertices together, at the same time applying repelling forces to all pairs of vertices to try to keep as much space as possible between them. This calculation is an iterative process where vertex positions are calculated again and again until equilibrium is reached. The result is usually a layout where connected vertices are closer together and where edge lengths are approximately equal.\nFor Zachary’s Karate Club study, which was a study of connection and community, we can imagine that a force-directed layout would be a good choice of visualization, and we will find that this is the case for many other network graphs we study. There are several different implementations of force-directed algorithms available. Perhaps the most popular of these is the Fruchterman-Reingold algorithm. The Figure below shows our karate network with the layout generated by the Fruchterman-Reingold algorithm, and we can see clear communities in the karate club oriented around Mr Hi and John A.\n\n# F-R algorithm\nset.seed(123)\nfr &lt;- layout_with_fr(karate)\nplot(karate, layout = fr)\n\n\n\n\nThe Kamada-Kawai algorithm and the GEM algorithm are also commonly used force-directed algorithms and they produce similar types of community structures as in Figures 3.9 and 3.10, respectively.\n\n# K-K algorithm\nset.seed(123)\nkk &lt;- layout_with_kk(karate)\nplot(karate, layout = kk)\n\n\n\n\n\n# GEM algorithm\nset.seed(123)\ngem &lt;- layout_with_gem(karate)\nplot(karate, layout = gem)\n\n\n\n\nAs well as force-directed and shape-oriented layout algorithms, several alternative approaches to layout calculations are also available. An important alternative to force-directed approaches it the multivariate scaling technique. The purpose of multidimensional scaling (MDS) is to provide a visual representation of the pattern of proximities among a set of actors.\n\nset.seed(123)\nmds &lt;- layout_with_mds(karate)\nplot(karate, vertex.label=V(karate)$name, vertex.label.cex=.5,layout = mds)\n\n\n\n\nThe MDS layout plots similar actors close to eachother, so actor 10 and actor 31 are similar. A drawback of the MDS layout is that similar actors are sometimes plotted on top of each others, which provides us with a less aesthetically pleasing visualization.\n\nset.seed(123)\ndh &lt;- layout_with_dh(karate)\nplot(karate, vertex.label=V(karate)$name, vertex.label.cex=.5,layout = dh)\n\n\n\n\n\n4.1.5 A visualization example\nAbove we exhibited several igraph.plotting aspects, however the aesthetic aspect. For a second practical example, we make use of the organizational network data from part 2. These data are from a well-known series of studies by David Krackhardt of a corporate hierarchy.\nThere a number of igraph.plotting options that are useful. The asp function was used before already (i prefer the aspect ratio 0.6 for the html output).\n\n\nmargin: Empty space margins around the plot, vector with length 4\n\nframe: if TRUE, the plot will be framed\n\nmain: If set, adds a title to the plot\n\nsub: If set, adds a subtitle to the plot\n\nasp: Numeric, the aspect ratio of a plot (y/x)\n\npalette: A color palette to use for vertex color\n\nrescale: Whether to rescale coordinates to [-1,1]. Default is TRUE.\n\n\nInitial.matrix &lt;- read.csv(\"data/Krack-High-Tec-Friendship-edges.csv\", header=TRUE, row.names=1)\nmatrix &lt;- as.matrix(Initial.matrix) \nfriendship &lt;- graph.adjacency(matrix, mode=\"directed\", weighted=NULL)\n\nnodes &lt;- read.csv(file = \"data/Krackh-High-Tec-nodes2.csv\", sep = \";\", header=TRUE)\n\nV(friendship)$age    = nodes$AGE\nV(friendship)$tenure = nodes$TENURE\nV(friendship)$level =  nodes$LEVEL\n\nplot(friendship, asp=0.6)\n\n\n\n\nThis plot is not really helpful. Let’s take some steps to improve the visualization. I add labels for the names (recall that the attribute label is now added to the igraph object friendship), but take care that this label is next to the vertex. The size is reduced, arrow size is reduced, edge is curved a bit.\n\nV(friendship)$label =  nodes$names\n\n\nplot(friendship, \n     vertex.size=6, \n     vertex.label.cex=.6,\n     vertex.label.dist=1.5,\n     vertex.label.degree=-pi/2,\n     edge.curved=.2,\n     edge.arrow.size=.3,\n     asp=0.6)\n\n\n\n\nA good drawing can also help us to better understand how a particular “ego” (node) is “embedded” (connected to) its “neighborhood” (the actors that are connected to ego, and their connections to one another) and to the larger graph (is “ego” an “isolate” a “pendant”?). By looking at “ego” and the “ego network” (i.e. “neighborhood”), we can get a sense of the structural constraints and opportunities that an actor faces; we may be better able to understand the role that an actor plays in a social structure.\nIn our example we could be interested in the embedding of the different hierarchical levels (coded 1,2 and 3; 1=CEO, 2 = Vice President, 3 = manager)\nFirst we create a vector color color &lt;- c(\"red\", \"blue\", \"yellow\"), after that color[V(friendship)\\$level] is used to assign a color to the values in the “V(friendship)$level” vector. An alternative way is to create a color vector color&lt;-V(friendship)\\$level, and then assign the colors to the values in the vector color (color[1]&lt;-“red”, color[2]&lt;-“blue”,color[3]&lt;-“yellow”).\n\ncolor &lt;- c(\"red\", \"blue\", \"yellow\")\nV(friendship)$color &lt;- color[V(friendship)$level]\nshape &lt;- c(\"crectangle\", \"square\", \"circle\")\nV(friendship)$shape &lt;- shape[V(friendship)$level]\n\nplot(friendship, \n     vertex.size=6, \n     vertex.label.cex=.6,\n     vertex.label.dist=1.5,\n     vertex.label.degree=-pi/2,\n     edge.curved=.2,\n     edge.arrow.size=.3,\n     asp=0.6)\n\nlegend(x=-1, y=-0.6, c(\"ceo\",\"vp\", \"manager\"), pch=21,\n       col=\"#777777\", pt.bg=color, pt.cex=2, cex=.8, bty=\"n\", ncol=1)\n\n\n\n\nAdjusting the size of nodes according to attributes can be useful as well, particularity if the size is proportional to a degree-like measure. It is clear in this visualization that some of the managers are well connected in the friendship network, the CEO and VP are less well connected (which is not necessarily bad).\n\nplot(friendship, \n     vertex.size=degree(friendship), \n     vertex.label.cex=.6,\n     vertex.label.dist=1.5,\n     vertex.label.degree=-pi/2,\n     edge.curved=.2,\n     edge.arrow.size=.3,\n     asp=0.6)\n\n\n\n\nIt is common to adjust the appearance of edges as well. A classic example is the distinction between weak ties and strong ties (often the weak ties are depicted as dotted lines). In our example data we know whether a friendship nomitation is reciprocated or not. Based on this information we could construct an edge attribute “strength of tie” assuming that a reciprocated friendship nomination indicates that a tie is stronger.\nRecall that we read the data into an adjacency matrix (matrix) that was used to create an igraph object. We use this matrix to calculate whether a nomination is reciprocated or not (this does not work well in igraph objects). By transposing and then adding the transposed matrix to the original we get a weighted network (0=no connection, 1=weak, 2=strong).\n\ntmatrix=t(matrix)\nrmatrix = tmatrix+matrix\nrmatrix\n\n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\nX1  0 2 0 2 0 0 0 1 0  0  1  2  0  0  1  2  1  0  1  0  0\nX2  2 0 0 1 1 1 0 0 0  0  1  0  0  0  0  1  1  2  1  0  2\nX3  0 0 0 0 0 0 0 0 0  1  1  0  0  1  1  0  1  0  2  0  0\nX4  2 1 0 0 0 0 0 2 0  0  1  2  0  0  0  1  2  0  0  0  0\nX5  0 1 0 0 0 0 0 0 1  1  2  0  1  1  1  0  2  0  2  0  1\nX6  0 1 0 0 0 0 1 0 1  0  0  1  0  0  1  0  2  0  0  0  1\nX7  0 0 0 0 0 1 0 0 0  0  0  0  0  1  0  0  1  0  0  0  0\nX8  1 0 0 2 0 0 0 0 0  1  1  0  0  0  0  0  1  0  0  0  0\nX9  0 0 0 0 1 1 0 0 0  1  1  0  0  0  1  0  1  0  0  0  0\nX10 0 0 1 0 1 0 0 1 1  0  0  1  0  0  0  1  1  0  0  1  0\nX11 1 1 1 1 2 0 0 1 1  0  0  1  2  0  2  0  2  1  2  1  0\nX12 2 0 0 2 0 1 0 0 0  1  1  0  0  0  0  0  2  0  1  0  2\nX13 0 0 0 0 1 0 0 0 0  0  2  0  0  0  0  0  0  0  0  0  0\nX14 0 0 1 0 1 0 1 0 0  0  0  0  0  0  2  0  1  0  1  0  0\nX15 1 0 1 0 1 1 0 0 1  0  2  0  0  2  0  0  1  0  2  0  0\nX16 2 1 0 1 0 0 0 0 0  1  0  0  0  0  0  0  1  0  0  0  0\nX17 1 1 1 2 2 2 1 1 1  1  2  2  0  1  1  1  0  0  1  1  2\nX18 0 2 0 0 0 0 0 0 0  0  1  0  0  0  0  0  0  0  0  1  1\nX19 1 1 2 0 2 0 0 0 0  0  2  1  0  1  2  0  1  0  0  1  0\nX20 0 0 0 0 0 0 0 0 0  1  1  0  0  0  0  0  1  1  1  0  0\nX21 0 2 0 0 1 1 0 0 0  0  0  2  0  0  0  0  2  1  0  0  0\n\nfriendship2 &lt;- graph.adjacency(rmatrix, mode=\"undirected\", weighted=TRUE)\n\nnodes &lt;- read.csv(file = \"data/Krackh-High-Tec-nodes2.csv\", sep = \";\", header=TRUE)\n\nV(friendship2)$age    = nodes$AGE\nV(friendship2)$tenure = nodes$TENURE\nV(friendship2)$level =  nodes$LEVEL\nV(friendship2)$label =  nodes$names\n\ncolor &lt;- c(\"red\", \"blue\", \"yellow\")\nV(friendship2)$color &lt;- color[V(friendship)$level]\nshape &lt;- c(\"crectangle\", \"square\", \"circle\")\nV(friendship2)$shape &lt;- shape[V(friendship)$level]\n\ne=E(friendship2)$weight\ne\n\n [1] 2 2 1 1 2 1 2 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 2 2 1 2 1 2 1 1 2 1 1 1 2 2 1\n[39] 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 2 1 2 1 2 2 1 1 1 2 1 1 1 2\n[77] 1 1 1\n\nfriendship2\n\nIGRAPH 4947be4 UNW- 21 79 -- \n+ attr: name (v/c), age (v/n), tenure (v/n), level (v/n), label (v/c),\n| color (v/c), shape (v/c), weight (e/n)\n+ edges from 4947be4 (vertex names):\n [1] 1 --2  1 --4  1 --8  1 --11 1 --12 1 --15 1 --16 1 --17 1 --19 2 --4 \n[11] 2 --5  2 --6  2 --11 2 --16 2 --17 2 --18 2 --19 2 --21 3 --10 3 --11\n[21] 3 --14 3 --15 3 --17 3 --19 4 --8  4 --11 4 --12 4 --16 4 --17 5 --9 \n[31] 5 --10 5 --11 5 --13 5 --14 5 --15 5 --17 5 --19 5 --21 6 --7  6 --9 \n[41] 6 --12 6 --15 6 --17 6 --21 7 --14 7 --17 8 --10 8 --11 8 --17 9 --10\n[51] 9 --11 9 --15 9 --17 10--12 10--16 10--17 10--20 11--12 11--13 11--15\n[61] 11--17 11--18 11--19 11--20 12--17 12--19 12--21 14--15 14--17 14--19\n+ ... omitted several edges\n\n#edge.lty = E(fri)\n\nplot(friendship2, \n     edge.lty=E(friendship2)$weight,\n     edge.width=(1/E(friendship2)$weight)*1.5,\n     vertex.label.cex=.6,\n     vertex.size=degree(friendship2),\n     vertex.label.dist=1.5,\n     vertex.label.degree=-pi/2,\n     edge.curved=.2,\n     edge.arrow.size=.3,\n     asp=0.6)\n\n\n\n\nThere is no single “right way” to represent network data with graphs. There are a few basic rules.Different ways of drawing pictures of network data can emphasize (or obscure) different features of the social structure. It’s usually a good idea to play with visualizing a network, to experiment and be creative.\n\n4.1.5.1 Network Layouts\nThe layout options provided in igraph work algorithmically or heuristically, usually with some randomness. So, even with the same layout option, a different graphic layout will be produced each time the network is plotted. By setting a seed (set.seed) we can ensure reproducibility.\n\n# this is a function to present two graphs in one figure (one row and two columns)\npar(mfrow=c(1,2))\n\n# set seed for reproducibility\nset.seed(123)\nlmds&lt;-layout.mds(friendship)\nlfr&lt;-layout.fruchterman.reingold(friendship)\n\nplot(friendship, \n     layout = lmds,\n     vertex.label.cex=.6,\n     vertex.size=6,\n     vertex.label.dist=1.5,\n     vertex.label.degree=-pi/2,\n     edge.curved=.2,\n     edge.arrow.size=.3,\n     asp=1.4,\n     main=\"Multidimensional scaling layout\")\n\nplot(friendship, \n     layout = lfr,\n     vertex.label.cex=.6,\n     vertex.size=6,\n     vertex.label.dist=1.5,\n     vertex.label.degree=-pi/2,\n     edge.curved=.2,\n     edge.arrow.size=.3,\n     asp=1.4,\n     main=\"Fruchterman Reingold layout\")\n\n\n\n\n\ngraphics.off()"
  },
  {
    "objectID": "3.html#centrality",
    "href": "3.html#centrality",
    "title": "\n4  Inequality and network position\n",
    "section": "\n4.2 Centrality",
    "text": "4.2 Centrality\nIn this section we look at measures of network centrality, which we use to identify structurally important actors. We also discuss possible ideas for identifying important edges. Centrality originally referred to how central actors are in a network’s structure. It has become abstracted as a term from its topological origins and now refers very generally to how important actors are to a network. Topological centrality has a clear definition, but many operationalizations. Network “importance” on the other hand has many definitions and many operationalizations.\nThere are four well-known centrality measures: degree, betweenness, closeness and eigenvector - each with its own strengths and weaknesses. The usefulness of each depends on the context of the network, the type of relation being analyzed and the underlying network morphology.\nEvery node-level measure has its graph-level analogue. Centralization measures the extent to which the ties of a given network are concentrated on a single actor or group of actors. We can also look at the degree distribution. It is a simple histogram of degree, which tells you whether the network is highly unequal or not.\n\n4.2.1 The Medici dataset\nWe will use John Padgett’s Florentine Families dataset. It is part of a famous historical dataset about the relationships of prominent Florentine families in 15th century Italy. The historical puzzle is how the Medici, an upstart family, managed to accumulate political power during this period. Padgett’s goal was to explain their rise.\nHe looked at many relations. We have access to marriage, credit, and business partnership ties, but we will focus on marriage and business partnerships for now. Marriage was a tool in diplomacy, central to political alliances (these relations were used in the lecture). We focus here on the business relations.\nBased on this plot, which family do you expect is most central?\n\n4.2.2 Degree Centrality\nThe simplest measure of centrality is degree centrality. As discussed in the previous part, it counts how many edges each node has - the most degree central actor is the one with the most ties.\nNote: In a directed network, you will need to specify if in or out ties should be counted. These will be referred to as in or out degree respectively. If both are counted, then it is just called degree.\nDegree centrality is calculated using the degree function in R. It returns how many edges each node has. Note that we first have to simplify the graph.\n\ndegree(PM)\n\n  ACCIAIUOLI      ALBIZZI    BARBADORI     BISCHERI   CASTELLANI       GINORI \n           1            3            2            3            3            1 \n    GUADAGNI LAMBERTESCHI       MEDICI        PAZZI      PERUZZI        PUCCI \n           4            1            6            1            3            0 \n     RIDOLFI     SALVIATI      STROZZI   TORNABUONI \n           3            2            4            3 \n\ndegree(PB)\n\n  ACCIAIUOLI      ALBIZZI    BARBADORI     BISCHERI   CASTELLANI       GINORI \n           0            0            4            3            3            2 \n    GUADAGNI LAMBERTESCHI       MEDICI        PAZZI      PERUZZI        PUCCI \n           2            4            5            1            4            0 \n     RIDOLFI     SALVIATI      STROZZI   TORNABUONI \n           0            1            0            1 \n\n\nWe can assign the output to a variable in the network and size the nodes according to degree.\n\nV(PB)$degree &lt;- degree(PB) # assignment\n\nplot(PB, vertex.label.cex = .6, vertex.label.color = \"black\", vertex.size = V(PB)$degree, vertex.label.cex = .2, asp=0.6, xlab=\"Marriage relations\") # sized by degree\n\n\n\n\nThe problem is that the degree values are a little small to plot well. We can use a scalar to increase the value of the degree but maintain the ratio.\n\nplot(PB, \n     vertex.label.cex = .6, \n     vertex.label.color = \"black\", \n     vertex.size = V(PB)$degree*3)\n\n\n\n\n\n4.2.3 Betweenness Centrality\nBetweenness centrality captures which nodes are important in the flow of the network. It makes use of the shortest paths in the network. A path is a series of adjacent nodes. For any two nodes we can find the shortest path between them, that is, the path with the least amount of total steps (or edges). If a node C is on a shortest path between A and B, then it means C is important to the efficient flow of goods between A and B. Without C, flows would have to take a longer route to get from A to B.\nThus, betweenness effectively counts how many shortest paths each node is on. The higher a node’s betweenness, the more important they are for the efficient flow of goods in a network.\nIn igraph, betweenness() computes betweenness in the network.\n\nbetweenness(PB, directed = FALSE)\n\n  ACCIAIUOLI      ALBIZZI    BARBADORI     BISCHERI   CASTELLANI       GINORI \n         0.0          0.0         25.0          2.5          5.0          0.0 \n    GUADAGNI LAMBERTESCHI       MEDICI        PAZZI      PERUZZI        PUCCI \n         0.0          6.0         24.0          0.0         13.5          0.0 \n     RIDOLFI     SALVIATI      STROZZI   TORNABUONI \n         0.0          0.0          0.0          0.0 \n\n\nWe can again assign the output of betweenness() to a variable in the network and size the nodes according to it.\n\nV(PB)$betweenness &lt;- betweenness(PB, directed = F) # assignment\n\nplot(PB, \n     vertex.label.cex = .6, \n     vertex.label.color = \"black\", \n     vertex.size = V(PB)$betweenness) # sized by betweenness\n\n\n\n\nBetweenness centrality can be very large. It is often helpful to normalize it by dividing by the maximum and multiplying by some scalar when plotting.\n\nplot(PB,\n     vertex.label.cex = .6, \n     vertex.label.color = \"black\", \n     vertex.size = V(PB)$betweenness/max(V(PB)$betweenness) * 20)\n\n\n\n\n\n4.2.4 Closeness Centrality\nWith closeness centrality we again make use of the shortest paths between nodes. We measure the distance between two nodes as the length of the shortest path between them. Farness, for a given node, is the average distance from that node to all other nodes. Closeness is then the reciprocal of farness (1/farness).\n\ncloseness(PB)\n\n  ACCIAIUOLI      ALBIZZI    BARBADORI     BISCHERI   CASTELLANI       GINORI \n         NaN          NaN   0.05882353   0.04000000   0.05000000   0.04545455 \n    GUADAGNI LAMBERTESCHI       MEDICI        PAZZI      PERUZZI        PUCCI \n  0.03125000   0.04166667   0.05263158   0.03571429   0.05263158          NaN \n     RIDOLFI     SALVIATI      STROZZI   TORNABUONI \n         NaN   0.03571429          NaN   0.03571429 \n\n\nNote that the isolated families have an undefined distance to others in the network. Adjusting node size by closeness can only be done when replacing the NaN.\n\nd &lt;- closeness(PB)\nd[is.na(d)] &lt;- 0\n\nplot(PB,\n     vertex.label.cex = .6, \n     vertex.label.color = \"black\", \n     vertex.size=d*200)\n\n\n\n\n\n4.2.5 Eigenvector Centrality\nDegree centrality only takes into account the number of edges for each node, but it leaves out information about ego’s alters.\nHowever, we might think that power comes from being tied to powerful people. If A and B have the same degree centrality, but A is tied to all high degree people and B is tied to all low degree people, then intuitively we want to see A with a higher score than B.\nEigenvector centrality takes into account alters’ power. It is calculated a little bit differently in igraph. It produces a list object and we need to extract only the vector of centrality values.\n\nevcent(PB)$vector\n\n  ACCIAIUOLI      ALBIZZI    BARBADORI     BISCHERI   CASTELLANI       GINORI \n   0.0000000    0.0000000    0.8289579    0.7310627    0.8305427    0.4046458 \n    GUADAGNI LAMBERTESCHI       MEDICI        PAZZI      PERUZZI        PUCCI \n   0.4992669    0.9235790    0.5120959    0.1545184    1.0000000    0.0000000 \n     RIDOLFI     SALVIATI      STROZZI   TORNABUONI \n   0.0000000    0.1545184    0.0000000    0.1545184 \n\n\n\n4.2.5.1 Measure Correlations\nMost of these measures are highly correlated, meaning they don’t necessarily capture unique aspects of pwoer. However, the amount of correlation depends on the network structure. Let’s see how the correlations between centrality measures looks in the Florentine Family network. cor.test(x,y) performs a simple correlation test between two vectors.\nMarriage paradox: Do their marriage partners have more marriage partners than they do? We can use `knn’ command for this, which calculates the average neareast neigbor degree of a vertice.\n\n# degrees of your friends\n\nneighbor_degrees &lt;- knn(PB)$knn\ndegrees &lt;- degree(PB)\nmean(neighbor_degrees, na.rm = T)\n\n[1] 3.830303\n\nmean(degrees)\n\n[1] 1.875\n\n# plot neighbor degrees vs. ego degrees\nhist(neighbor_degrees)\n\n\n\nhist(degrees)\n\n\n\n\nNote: We can see that most nodes in the marriage network have low betweenness centrality, and only one node has more than 40 betweenness. Degree distributions tend to be right-skewed; that is, only a few nodes in most networks have most of the ties. Evenly distributed degree is much rarer."
  },
  {
    "objectID": "3.html#variation-in-centrality",
    "href": "3.html#variation-in-centrality",
    "title": "\n4  Inequality and network position\n",
    "section": "\n4.3 Variation in centrality",
    "text": "4.3 Variation in centrality\nCentralization measures the extent to which a network is centered around a single node. The closer a network gets to looking like a star, the higher the centralization score will be. Below are two extreme network structure, on the one hand the Wheel structure (aka star structure) with a maximum variation in network centrality, on the other hand we have the circle network, with no variation of centrality scores.\n\nsstar &lt;- make_star(10, center = 1, mode = \"undirected\")\nsfull &lt;- make_full_graph(10, directed = FALSE, loops = FALSE)\n\nV(sfull)$name &lt;- letters[seq_len(vcount(sfull))]\nV(sstar)$name &lt;- letters[seq_len(vcount(sstar))]\n\npar(mar = c(1,1,1,1), mfrow=c(1,2))\nplot(sfull, main=\"Clique: decentralized network\")\nplot(sstar, main= \"Wheel: centralized network\")\n\n\n\n\n\n4.3.1 Classic communication experiments\nIn the golden age of social psychology a series of studies, the so-called “Bavelas-Smith-Leavitt experiments” was used to study how network structure could affect team problem solving. The figure below is a quick summary of the original experiment (from Burt et al. 2022). Five subjects are assigned at random to positions in the four displayed communication networks. The networks are simplified in that connections are all or nothing (no variable-strength connections) and access to each structural hole is all or nothing (no shared access).\n\nEach subject is given a card containing five of the six symbols displayed at the top of the figure. One symbol is on all five cards. The team coordination task is to determine, as quickly as possible, which symbol is on all five cards. Seated around a card table passing written notes, subjects communicate through connections displayed in the figure. A trial is complete when all five teammates submit an answer. Completion does not depend on accuracy. After solving the task for the first trial, the team is presented with another, and another, until they complete all trials, or run out of time. Each trial task involves the same six symbols, but the particular symbol held in common during a trial varies from trial to trial.\nSummary results from Leavitt (1949, 1951) are given in the table below the sociograms. Groups in the WHEEL network solve the problem more quickly (32.0 s versus 50.4 for the CIRCLE), involving fewer messages (43.0 messages per person versus 83.8 in the CIRCLE), but finish with a lower level of satisfaction (44.4 average survey response for people in the WHEEL on 100-point response to “How did you like your job in the group?” versus 65.6 for people in the CIRCLE).\nThe task was deliberately simple in the original experiment. Experiments with complex tasks soon followed the original. Sidney Smith, the person who designed the figure experiment run in 1948, subsequently ran a “noisy marble” version in 1950. Complexity is introduced by making more abstract the symbols on which subjects coordinate. The task is to identify which of six marbles teammates have in common. The initial 15 trials are simple in that the six marbles obviously differ by solid color (red, blue, black, yellow, green, and white). The subsequent 15 trials are complex in that the marbles differed by cloudy, mottled, indistinct colors. They were still easy to distinguish if they could be directly compared, but it was very difficult to describe each one clearly and unambiguously.” In other words, subjects in the complex trials of “noisy marble” had to coordinate on words to identify marbles in addition to determining which marbles each held.\nNot surprisingly, coordination on complex tasks requires more time, involves more messages between subjects, more erroneous answers, and leaves subjects feeling less positive about the experience (succinctly shown in Shaw, 1954). More surprising and not anticipated by the researchers was the fact that the CIRCLE network is more effective than the WHEEL for coordination on a complex task. Subjects in the CIRCLE network show faster learning and submit fewer wrong answers. Christie et al. (1952) propose that the sharp difference between leader and follower in the WHEEL network — which is an advantage for simple coordination — is a disadvantage for complex coordination because followers are too passive in their confusion, and leaders too unaware of the confusion among followers. Teammate confusion is more apparent to teammates in the CIRCLE network, so they can deal with it. In corroboration, when the leader in the WHEEL network is given feedback at the end of each trial on the wrong answers submitted by teammates, their confusion was more evident to the leader, and WHEEL network performance improves visibly (Christie et al., 1952:141, 154).\n\n4.3.2 Network structure, success and leadership perception\nThe renovated classic experiment described above was again used to study the whether access to so-called “structural holes” is associated with success, and perceptions of leadership. A structural hole can be understood as a gap between two individuals who have complementary sources to information. In the figure above in the CIRCLE network all actors are in fact bridging a structural hole. Actor A bridges a structural hole between actors B and E. In the CHAIN network actor A is not bridging a structural hole. In the figure the “holes” column is a so-called bridge count, which is a simple and intuitive measure of structural holes in a network. Bridge is defined as a relation between two individuals if there is no indirect connection between them through mutual contacts.\nStructural holes theory was constructed by Ronald Burt, and was conceptually inspried by the strength of weak ties theory, the influential theory devised by Mark Granovetter (more about that theory in the diffusion network part of the course), and the betweenness centrality ideas discussed above. The theory is that structural holes are opportunities to broker information across groups separated by the holes, which gives people with access to structural holes information advantages of breadth, timing, and arbitrage, so such people — network brokers — are more likely to detect and develop good ideas into rewarding achievements.\nin the experiment the hypothesis was that access to structural holes increases the odds that a person is perceived by colleagues to be a leader. People are perceived to be leaders when they behave as network brokers, which is to say, when they coordinate information across structural holes.\n\nIn the above figure the vertical axis is percent of citations to subject in response to question: “Did your group have a leader? If so, who?” Solid dots are mean number of citations received by subjects at the same level of network constraint.\nThe most readily recognized leaders are positioned as the hub in a WHEEL.The individuals least often cited as leaders are in small, closed networks — 0 %, 0 %, and 3 % respectively cited as leaders in the pendant positions of the WHEEL, CHAIN, and Y networks in the original study, 0 % cited here as leaders in the pendant positions of a WHEEL network, and 3 % cited as leaders in 3-person clique networks.\n\n4.3.3 Illicit networks\nThe application of social network analysis to criminal phenomena has gained considerable attention. Network studies of crime often consider illicit networks, social networks in which actors seek to keep themselves and their activities concealed to avoid detection. Examples include secret societies, criminal enterprises, drug distribution networks, and terrorist networks. Illicit networks are goal oriented in that they operate to realize their objectives, such as collusion in a price-fixing scheme, trafficking illicit drugs, distributing stolen property, or executing a terrorist attack. The structure of illicit networks is influenced by the fact that the enterprise must accomplish its goals despite scrutiny and regulation from law enforcement and other official bodies. This makes illicit networks different from non-illicit networks. To some extent, these differences have led to a sense that illicit networks face a distinct trade-off between efficiency and concealment, with consequences for network structure. The most efficient communication network or task coordination structure might be one that makes the enterprise vulnerable to detection. However, structures that increase concealment (such as sparse communication networks) might be inefficient for accomplishing the enterprise’s tasks. Nevertheless, as Morselli (2009) points out, illicit networks requiring resource sharing are under pressure from law enforcement, and face constraints on the kinds of network structures that can be maintained.\nBaker et al (1995) examined the link between risk and security within a network structure. Their study on the social organization of three segments in the heavy electrical equipment industry, in which collusion and price-fixing were prevalent, revealed the importance of players operating in the peripheries of a criminal network. These peripheral players were less targeted and less sanctioned than more central players. Remaining in the periphery was a way of protecting oneself.\n\nAt the group level, having a periphery (or lacking a clear-cut core) is a way of opting for security before efficiency: reducing risk in the network does have a trade-off in that each operation and the transmission of information take longer to process. Knowing that the risks associated with covert activities generally lead to the end of a network or the termination of the potential actions of targeted participants, a loss in efficiency clearly becomes an acceptable outcome for many participants. Thus, within the efficiency/security trade-off, security appears to be the predominant concern in criminal networks.\nThe study of Baker focused at organizations. Human illicit networks are similar in the sense that a trade off has to be made between efficiency and security. Erickson (1981) stressed the importance of security in covert networks from a social network perspective in her re-analysis of six case studies of secret societies under risk: the Auschwitz underground during World War 2; a rebellion group in 19th century China; a New York City Cosa Nostra family; a heroin market in San Antonio, TX; a sample of marijuana consumers from Cheltenham, England; and a Norwegian resistance group during World War 2. She argued that when networks are obliged to choose between efficiency and security, organizational structures with a proven level of endurance and an established reputation opt for the latter. Her key point was that in order to understand the structure of a network, the “conditions under which they exist” must first be appreciated (p. 189). Risky conditions generally lead participants to assure security within the network. One way the network members of Erickson’s case studies achieved this was by relying primarily on pre-existing networks that formed the foundation upon which each secret society was designed to compensate for risk."
  },
  {
    "objectID": "3.html#exercise",
    "href": "3.html#exercise",
    "title": "\n4  Inequality and network position\n",
    "section": "\n4.4 Exercise",
    "text": "4.4 Exercise\nThe data arose from an early experiment on computer mediated communication. Fifty academics interested in interdisciplinary research were allowed to contact each other via an Electronic Information Exchange System (EIES). The data collected consisted of all messages sent plus acquaintance relationships at two time periods (collected via a questionnaire).The data includes the 32 actors who completed the study. In addition attribute data on primary discipline and number of citations was recorded. TIME_1 and TIME_2 give the acquaintance information at the beginning and end of the study. This is coded as follows: 4 = close personal fiend, 3= friend, 2= person I’ve met, 1 = person I’ve heard of but not met, and 0 = person unknown to me (or no reply). NUMBER_OF MESSAGES is the total number of messages person i sent to j over the entire period of the study. The attribute data gives the number of citations of the actors work in the social science citation index at the beginning of the study together with a discipline code: 1 = Sociology, 2 = Anthropology, 3 = Mathematics/Statistics, 4 = other.\nEdges are in “Freeman’s_EIES.xlsx”. Nodes in “Freeman_EIES_Attribute.xlsx”.\n\nRead the data, a relation should indicate that a tie is a friend (so code 3 & 4).\nPlot the network, include department attribute, make vertex size proportional to scientific impact\nPlot and compare a MDS and FR layout.\nThere are two illicit network datasets at your disposal. Compare a gang (MONTREALGANG.csv) and terrorist network (MALI.csv). What do you expect a priori?\nWho is the most important actor in the Montreal network? Why?\nWho is the most important actor in the Mali network? Why?"
  },
  {
    "objectID": "4.html#components",
    "href": "4.html#components",
    "title": "\n5  Social Cohesion\n",
    "section": "\n5.1 Components",
    "text": "5.1 Components\nThe most basic form of a network group is a component. In a connected component, every node is reachable via some path by every other node. Most network datasets have only a single large connected component with a few isolates - however, some unique datasets might have three or four large, distinct components.\nIn a directed graph, components can be weakly or strongly connected. If node i can reach j via a directed path and j can reach i via a directed path, for all i and j nodes in the component, then we say the component is strongly connected. If all nodes are only reachable from a single direction, (i.e. i can reach j via a directed path, but j can’t reach i), then we say the component is weakly connected.\nThe decompose.graph function in igraph will take a network and decompose it into its connected components. We can then analyze each component separately.\nTo illustrate we use again the first organizational network collected, consisting of observational data on 14 Western Electric (Hawthorne Plant) employees from the bank wiring room first presented in Roethlisberger & Dickson (1939). We focus on helping relations (who helps whom), so these are directed data.\n\n\n\n\n\n\ncomponents(RDHLP, mode=c(\"strong\"))\n\n$membership\nI1 I3 W1 W2 W3 W4 W5 W6 W7 W8 W9 S1 S2 S4 \n 5  4  3  3  3  3  2  3  3  3  3  3  1  3 \n\n$csize\n[1]  1  1 10  1  1\n\n$no\n[1] 5\n\ncomponent_list &lt;- decompose.graph(RDHLP, mode = \"strong\")\n\nThere is one major component, as is most often the case!\nConsider Moreno’s sociogram of a school class depicted below (this was one of the earliest networks ever collected). Here, it is self-evident that the network is made up of two primary groups, although the two groups are part of one component.\n\n\n\n\n\nThe two groups are connected by a bridge. In general, a bridge is a direct tie between nodes that would otherwise be in disconnected components of the graph. A bridge is often of major importance in a network (see the strength of weak ties theory). A bridge often connects two articulation points, vertices that when removed, disconnect the network. As can be seen in the figure below, there are four bridges, and six articulation points. Note that vertices 32 and 32 are not articulation points, since removing one of them (and hence the bridge), creates an isolate.\n\narticulation_points(iMoreno)\n\n+ 7/33 vertices, from 62ad0d7:\n[1] 15 10  9 29 21 18  1\n\nbridges(iMoreno)\n\n+ 4/46 edges from 62ad0d7:\n[1] 10--15  9--10  1--18 32--33\n\na&lt;- articulation_points(iMoreno)\nb&lt;-bridges(iMoreno)\n\ne&lt;-rep(1,ecount(iMoreno))\ne[b]&lt;-3\nV(iMoreno)$color[a]&lt;- \"black\"\n\n#E(edge.width)[g]&lt;-2 \n\nplot(iMoreno, layout = lay,\n     edge.arrow.size=0.3,\n     edge.width=e,\n     vertex.color= V(iMoreno)$color,\n     vertex.size=8,\n     vertex.label.dist=1.2,\n     vertex.label.cex=0.6, \n     main=\"articulation points and bridges\",\n     asp=0.6)"
  },
  {
    "objectID": "4.html#cliques",
    "href": "4.html#cliques",
    "title": "\n5  Social Cohesion\n",
    "section": "\n5.2 Cliques",
    "text": "5.2 Cliques\nWhile there are two clear subgroups (boys and girls) within those groups there are multiple smaller, subgroups of schoolchildren where all children are friends of each other. Such maximally connected groups are called cliques.\nThe idea of a clique is relatively simple. At the most general level, a clique is a sub-set of a network in which the actors are more closely and intensely tied to one another than they are to other members of the network. In terms of friendship ties, for example, it is not unusual for people in human groups to form “cliques” on the basis of age, gender, race, ethnicity, religion/ideology, and many other things. The smallest “cliques” are composed of two actors: the dyad. But dyads can be “extended” to become more and more inclusive – forming strong or closely connected regions in graphs. A number of approaches to finding groups in graphs can be developed by extending the close-coupling of dyads to larger structures.\nThe formal definition of a “clique” as it is used in network analysis is much more narrow and precise than the general notion of a high local density. Formally, a clique is the maximum number of actors who have all possible ties present among themselves. A “Maximal complete sub-graph” is such a grouping, expanded to include as many actors as possible.\n\nclique.number(iMoreno) # this returns the largest clique-size\n\n[1] 3\n\ncount_max_cliques(iMoreno, min=3) # counts the maximal cliques.\n\n[1] 10\n\n# The output of the following two commands is extensive, so lets skip that.\n\n# cliques(iMoreno, min=3) # cliques equal or larger to 3\n# maximal.cliques(iMoreno, min=3) #list all cliques equal or larger to 3\n\n# returns a numeric vector representing a histogram of  clique sizes, between  # the given minimum and maximum clique size.\nclique_size_counts(iMoreno) \n\n[1] 33 46 10\n\n\nSo there are 10 cliques with three children in each clique. Here is a plot of all the cliques. Note that some children are in multiple cliques.\n\n\n\n\n\nNote that clique size is relatively low (lower than you may have expected). In most social networks the upper limit of the size of a single clique is seven (see Killworth and Bernard, 1974)."
  },
  {
    "objectID": "4.html#structural-cohesion",
    "href": "4.html#structural-cohesion",
    "title": "\n5  Social Cohesion\n",
    "section": "\n5.3 Structural cohesion",
    "text": "5.3 Structural cohesion\nThe idea that collectivity is structurally cohesive to the extent that the social relations of its members hold it together is somewhat limited. Imagine a set of five actors that are connect via a chain.\n\npar(mfrow=c(1,2))\nplot(graph_from_literal(A---B, B---C, C---D, D---E), main=\"Chain\")\nplot(graph_from_literal(A---B, B---C, C---D, D---E, A---C,\n                        A---D, B---E, C---E, A---E, D---B), main=\"Clique\" ) \n\n\n\n\nIn the chain network actors are connected via only one path. Intuitively, the ability of the group to “hold together” increases with the number of independent ways that group members are linked. Increasing the number of paths between actors thus seems a way to increase cohesion in the network. However, the increase should not be through one individual actors (a leader), since then the network would become vulnerable again.\n[T]he organization of [cohesive] group ties should be distributed throughout the group in a relatively uniform manner. This implies the absence of any substructures that might be vulnerable, such as via a small number of \"cut-points\" to calving away from the rest of the structure. (Markovsky 1998:345)\nThis idea leads to the idea that cohesion is equal to the minimum number of actors who, if removed from the group, would disconnect the group. The clique network is according to this idea the most cohesive network.\n\ncohesion(iMoreno)\n\n[1] 0\n\n\nCohesion is zero since the network is disconnected, so no actors need to be removed. lets now select the largest component and find out the degree of cohesion in this subnetwork.\n\niMoreno.gc&lt;-largest_component(iMoreno)\ncohesion(iMoreno.gc)\n\n[1] 1\n\n\nThe figure above (articulation points and bridges) shows clearly that removing only one vertex, results in a disconnected network, hence cohesion is one (and fairly low). Contrast this with the cohesion of a clique (of five).\n\nclique &lt;-graph_from_literal(A---B, B---C, C---D, D---E, A---C,\n                        A---D, B---E, C---E, A---E, D---B)\ncohesion(clique)\n\n[1] 4"
  },
  {
    "objectID": "4.html#community-detection",
    "href": "4.html#community-detection",
    "title": "\n5  Social Cohesion\n",
    "section": "\n5.4 Community detection",
    "text": "5.4 Community detection\nA “community” can be defined as a cluster of nodes that are more connected internally than externally, either directly and/or indirectly. This differs from components and cliques that relies solely on the internal structure of a group.\n\n5.4.1 Modularity\nAn important characteristic of a network that is used in many community detection algorithms is that of modularity. Modularity is a measure of the structure of the network, specifically the extent to which nodes exhibit clustering where there is greater density within the clusters and less density between them (Newman 2006). Modularity can be used in an exploratory fashion, where an algorithm tries to maximize modularity and returns the node classification that is found to best explain the observed clustering. Conversely, modularity can be used in a descriptive fashion where the modularity statistic is calculated for any node classification variable of interest. For example, an analyst can calculate the modularity score for a friendship network given the gender of network members. Used this way, modularity reflects the extent to which gender explains the observed clustering among the friends in the network.\nModularity is a chance-corrected statistic, and is defined as the fraction of ties that fall within the given groups minus the expected such fraction if ties were distributed at random. The modularity statistic can range from −1/2 to +1. The closer to 1, the more the network exhibits clustering with respect to the given node grouping.\nConsider the following simple example of a network with nine nodes. We have two categorical vertex attributes which each classify the nodes into three groups\n\ng1 &lt;- graph.formula(A-B-C-A,D-E-F-D,G-H-I-G,A-D-G-A)\nV(g1)$grp_good &lt;- c(1,1,1,2,2,2,3,3,3)\nV(g1)$grp_bad &lt;- c(1,2,3,2,3,1,3,1,2)\n\n\nop &lt;- par(mfrow=c(1,2))\nplot(g1,vertex.color=(V(g1)$grp_good),\nvertex.size=20,main=\"Good Grouping\")\nplot(g1,vertex.color=(V(g1)$grp_bad),\nvertex.size=20,\nmain=\"Bad Grouping\")\n\n\n\npar(op)\n\nAs the figure suggests, the clustering that is evident in the network is better accounted for by the grp good node attribute compared to the grp bad variable. This can be confirmed by calculating the modularity score provided by the modularity function in igraph.\n\nmodularity(g1,V(g1)$grp_good)\n\n[1] 0.4166667\n\nmodularity(g1,V(g1)$grp_bad)\n\n[1] -0.3333333\n\n\nReal-world social networks are often characterized by clustering, but it is of course harder to judge the extent of the clustering by eye. Earlier we saw that there was interesting subgroup structure contained in the Moreno network.\n\nmodularity(iMoreno,V(iMoreno)$gender)\n\n[1] 0.4761342\n\n\nThe network exhibits clear clustering based upon gender. The groups show clear modularity, and can be called a “community”.\n\n5.4.2 Community Detection Algorithms\nIgraph supports several community detection algorithms.In the lecture the edge-betweenness algorithm has been discussed. This algorithm has intuitive appeal and works well, especially when the network size is not too large, and there is a reasonably clear clustering (that is: the proportion of each nodes links which link outside its community is not too high).\nThe linked article compares popular algorithms( https://www.nature.com/articles/srep30750). Its conclusion is that the multi-level aka the Louvain algorithm overall performs best. It is a different “greedy” approach for optimizing the modularity with respect to the “Fastgreedy” method. The Louvain algorithm partitions a graph into subsets of vertices by trying to maximize the modularity of the graph.\n\nThe algorithm starts its first phase with each vertex in its own community.\nVertices are moved into other communities, and modularity is calculated. When the algorithm reaches a point where further vertex moves do not increase modularity, it finishes its first phase.\nIn its second phase, the communities resulting from the first phase are aggregated to form a simpler pseudograph where each vertex represents a community. In this heuristic step, vertices are moved in this simpler graph with the aim of improving modularity. That is, communities may be combined if modularity is improved.\nThe first and second phases are repeated until modularity cannot be further improved.\n\n Lets compare the Louvain and edge betweenness algorithms.\n\nop &lt;- par(mfrow=c(1,2))\nceb &lt;- cluster_edge_betweenness(iMoreno)\nmodularity(ceb)\n\n[1] 0.6216919\n\nmembership(ceb)\n\n [1] 1 1 1 1 2 2 1 1 2 3 2 3 3 3 3 1 2 4 4 4 5 5 5 4 4 4 4 4 4 4 5 6 6\n\nplot(ceb, iMoreno,vertex.label=V(iMoreno)$name,\n    vertex.label.cex=.6,\nmain=\"Edge Betweenness\")\n\nceba &lt;- cluster_louvain(iMoreno)\nmodularity(ceba)\n\n[1] 0.629017\n\nmembership(ceba)\n\n [1] 1 1 1 1 1 1 1 1 2 2 2 3 3 3 3 1 2 4 4 4 5 5 5 4 4 4 4 4 4 4 5 6 6\n\nplot(ceba, iMoreno,vertex.label=V(iMoreno)$name,\n       vertex.label.cex=.6,\nmain=\"Louvain / multi-level\")\n\n\n\n\nAs you can see the outcomes are close, only three vertices are classified differently. The modularity of the Louvain solution is a tiny bit better.\n\ntable(membership(ceba), membership(ceb)) \n\n   \n     1  2  3  4  5  6\n  1  7  2  0  0  0  0\n  2  0  3  1  0  0  0\n  3  0  0  4  0  0  0\n  4  0  0  0 10  0  0\n  5  0  0  0  0  4  0\n  6  0  0  0  0  0  2\n\n\n\n5.4.3 Network structure and jargon\nRecall that in part 3 we discussed the so-called “Bavelas-Smith-Leavitt experiments” that were used to study how network structure could affect team problem solving. See the figure below that gives a quick summary of the original experiment (from Burt et al. 2022). Five subjects are assigned at random to positions in the four displayed communication networks. \nRecall that five subjects were assigned at random to positions in the four displayed communication networks. The networks are simplified in that connections are all or nothing (no variable-strength connections). Each subject is given a card containing five of the six symbols displayed at the top of the figure. One symbol is on all five cards. The team coordination task is to determine, as quickly as possible, which symbol is on all five cards. Seated around a card table passing written notes, subjects communicate through connections displayed in the figure.\nIn a subsequent replication of Burt et al (2022) the tasks was made more complex. In the original experiment, teammates coordinated with respect to familiar shapes (circle, triangle, diamond, square, plus, star). In the renovated experiment, subjects coordinate with respect to six “tangram” symbols that were previously used in the study of language coordination. To coordinate on these symbols, teammates have to agree on a language by which symbols can be identified. The symbols are shown in the figure below. The tangrams are listed in order of increasing variation in the jargon used by the teams to describe the symbols. So teams agreed quite often about the language to denote the first symbol “bunny”. Most common jargon for a symbol is listed under symbol with percent of teams using that jargon and number of other terms used as jargon. Rows below symbol list jargon words from diverse teams as illustration.\n\nFrom the results depicted in the Figure below it is clear that in better connected groups, more jargon is created (and thus used). Horizontal bars indicate median jargon use within each team network. Words used in the initial and final trials for the four labeled teams are given in the indicated figures. Numbers in the network sociograms indicate seven positions in the assigned networks. Parentheses contain mean percent jargon, mean team messages per trial during the final trials, and number of teams averaged. The four assigned networks are presented in order of increasing concentration in a single teammate (respectively 40%, 50%, 57%, and 100%).\n\n\n5.4.4 Roles and the evolution of networks\nIn our 0HV80 course we mainly discuss static structures of networks. This is an obvious simplification of reality. Networks evolve and so do the roles people play in networks.In our first lecture, research of Johnson et al (2003) was introduced. This research was conducted at the Amundsen-Scott South Pole Station. Data were collected on crewmembers’ networks of social interaction over each of three winter-over periods, when the station is completely isolated. In addition, data were collected on the informal roles played by crewmembers (e.g., instrumental leadership, expressive leadership).\n\nIn the figure the three winter-over years can be found, along with a score that indicates how coherent the network was during that period. The network in year C was less coherent, coherence is the extent to which a network forms a single group composed of a unitary core and periphery as opposed to being factionalized into two or more subgroups. Coherence is associated with consensus on critical informal social roles, and above all the critically important role of instrumental leader.\nJohnson et al. found that the globally coherent networks (year B and C) in winter-over groups were associated with group consensus on the presence of critically important informal social roles (e.g., expressive leadership). Weak leadership has been associated with catastrophic failure in polar expeditions and with low morale in other isolated settings. Effective leadership is based on prior experience, articulation of goals, flexibility, and degree of interaction with other winter-over personnel. Data obtained on leaders of previous Antarctic winter-over crews indicated that evaluations of effective leadership were based on the ability of individuals assuming these roles to minimize group conflict, effectively address problems such as abusive or alcoholic station members before they began to affect station morale, keep projects on schedule without overworking personnel, make calm and rational decisions during an emergency, be fair and impartial particularly in conflicts between navy and civilian personnel, and maintain a certain level of communication with other winter-over personnel through work-related and social activities without becoming too “chummy.” Leaders lacking these abilities were harshly criticized and blamed for low moral, group conflict, and inability to successfully complete projects with a minimum of mistakes.\nEarly on, Hall (1955) recognized the crucial importance of members’ agreement on group roles for producing coherent groups. In the absence of role consensus, we find ‘‘role collision,’’ described by Hare (1976) as a ‘‘type of conflict which may occur if two different individuals in a group perform roles which overlap in some respects.’’ Heterogeneity can produce effective groups by simply reducing the potential for role collision. The value of status and role heterogeneity is counterposed by the potential corrosive effect of heterogeneity in group members’ backgrounds (e.g., nonscientists vs. scientists) and other characteristics (Bernard and Killworth, 1973; Johnson and Finney, 1986; Palinkas, 1989a).\nIn addition to effective leadership, which is a high status role, deviants or low status individuals play an important role in the coherence of small networks. Deviant roles (“clowns”) emerge in many enduring groups, especially those in isolation (e.g., military and work groups; Antarctic exploration groups, and isolated commercial fish camps). The deviants in these examples function positively: promoting group solidarity, reducing boredom, and inhibiting group conflict. Deviance is not only a natural part of social groups; it is institutionalized, accepted, and rewarded. The positive functional aspects of such low status positions can make a considerable contribution to producing harmonious and effective small groups. Just as “charismatic” leadership is important, so too is the presence of ‘‘charismatic’’ deviance. Occupants of such a social position will function in roles that provide a common reference point (e.g., mascot) for all other group members, thereby promoting group cohesion. This role will typically manifest itself in humor and joking behavior. Such behavior is essential for coping with boredom brought about by prolonged periods of isolation.\nThere is abundant anecdotal evidence that lower social statuses have been important in past Polar expeditions. For instance, on his Antarctic expedition, Amundsen brought with him a cook named Lindstrom. As “Chef, baker, pastry-cook he provided surrogate domesticity. He was also instrument maker, taxidermist, housepainter . . . and clown.” In his marginal social position as cook, Lindstrom provided not only food, but also humor and comic relief, and greatly contributed to group harmony during the long winter. Because of his marginal position, Lindstrom was able to play the role of clown or court-jester without fear of any sanctions. Thus, inter-personal and inter-subgroup conflicts were reduced by the inclusion of this single member. In a study of Italian commercial fishermen in an isolated camp in Alaska, Johnson and Miller (1983) and Johnson and Finney (1986) described the example of a deviant member (i.e., the worst fisherman of the group) who helped to mitigate conflict between the two major subgroups within the network of fishermen. During the fishing season of 1980, a strike had idled most of the fishermen in the camp. This was a period of boredom, high stress, and high potential for inter-personal and inter-subgroup conflict. However, the deviant, because of his status and personal characteristics, emerged in the role of “court jester,” providing comic relief and a common reference point for all group members irrespective of subgroup affiliation. The other fishermen made fun of him, played pranks on him, and made him a fun topic of conversation. He was rewarded for his role and received valuable salmon as compensation. He maintained moderate proximities among members of both subgroups. His role was important in minimizing conflicts during this tense period. As other group members described him: “He is the bridge between the two groups,” and “He belongs to everyone.”"
  },
  {
    "objectID": "4.html#exercise",
    "href": "4.html#exercise",
    "title": "\n5  Social Cohesion\n",
    "section": "\n5.5 Exercise",
    "text": "5.5 Exercise\nWe use the same data that was used in part 3. Edges are in “Freeman’s_EIES.xlsx”. Nodes in “Freeman_EIES_Attribute.xlsx”.\nThe data arose from an early experiment on computer mediated communication. Fifty academics interested in interdisciplinary research were allowed to contact each other via an Electronic Information Exchange System (EIES). The data collected consisted of all messages sent plus acquaintance relationships at two time periods (collected via a questionnaire).The data includes the 32 actors who completed the study. In addition attribute data on primary discipline and number of citations was recorded. TIME_1 and TIME_2 give the acquaintance information at the beginning and end of the study. This is coded as follows: 4 = close personal friend, 3= friend, 2= person I’ve met, 1 = person I’ve heard of but not met, and 0 = person unknown to me (or no reply). NUMBER_OF MESSAGES is the total number of messages person i sent to j over the entire period of the study. The attribute data gives the number of citations of the actors work in the social science citation index at the beginning of the study together with a discipline code: 1 = Sociology, 2 = Anthropology, 3 = Mathematics/Statistics, 4 = other.\n\nPlot the network of close personal friends (so only code 4!) include department information.\nHow many components does the network have? Find and plot articulation points.\nPerform a community detection analysis on the network of close friend relationships. Visualize the communities. What is a better grouping, the department grouping or the communities?\nSelect the main component. Does the edge betweenness clustering algorithm produce the same result as the louvain algorithm? Plot both results in one figure.\nNow include not only the close personal friends, but focus on all friendships (so code 3 should be included, just as in the exercise of part 3. What is the cohesion of this network?\nWhat is the maximum clique size of the network of friends? How many of those cliques are there? Plot the largest clique(s)"
  },
  {
    "objectID": "5.html#network-inverventions",
    "href": "5.html#network-inverventions",
    "title": "\n6  Rationalization: Diffusion networks\n",
    "section": "\n6.1 Network inverventions",
    "text": "6.1 Network inverventions\nThe importance of social network influences on behaviors is well established, and the advantages of network approaches to understanding a wide variety of phenomena are clear. There is a accumulated body of evidence that indicates that social networks can be leveraged to accelerate behavior change, improve organizational efficiency, enhance social change, and improve dissemination and diffusion of innovations. In his much article Tom Valente distinguishes four prototypical network interventions.\n\n\nIndividuals. In the most basic network intervention, network data are used to identify individuals to act as ‘champions’.\n\n\nThe most frequent intervention of this type is the use of opinion leaders. Opinion leaders are individuals who exert a significant amount of influence within their network and who can affect the opinions of connected individuals. In social networks opinion leaders are often more central nodes. Note that a direct way to identify opinion leaders is to ask members of a social networks who are most influential.\nLeaders may not always be the best change agents. Leaders have a vested interest in the status quo, whereas bridging individuals (who link non- or loosely connected groups) may be more amenable to change and may be in a better position to change others. For example, when diffusion between groups is expected to be difficult, bridging individuals may be more effective change agents. Bridging individuals may be preferred as change agents when the behavior or policy is controversial or not likely to be well accepted initially. Bridging nodes can be identified as brokers who have many connections to people who are not directly connected or as bridges whose connections maximally increase network cohesion.\nLow-threshold change agents should be recruited when the researcher wants to create early momentumfor the change and accelerate the time to reach a critical mass or tipping point. Low-threshold adopters are individuals willing to adopt a new idea earlier than their peers. Identifying low-threshold adopters as change agents requires some prior knowledge of behavioral adoption of a related innovation.\n\n\n\nSegmentation. In contrast to individual approaches in which certain individuals are recruited to be change proponents, segmentation approaches identify groups of people to change at the same time. For example, companies often introduce new procedures at separate locations sequentially rather than having all locations adopt the new procedures simultaneously. In some cases, behavior change is a group decision owing to the interdependent nature of the innovation or behavior change process. People often view themselves as members of a community of practice with established norms and processes that can only change when the whole group changes. For example, a new workflow practice or technology standard may be difficult to adopt unless the entire group agrees to use the system at the same time. Communication technologies such as fax machines, texting, and social networking increase in value as more users adopt the technology or standard. Groups can either be mutually exclusive or “cliques,” which allow for overlapping group membership. Interventions can be delivered to the groups separately or sequentially. A group structure that occurs in many intraorganizational networks is a core-periphery structure in which core members are densely connected to one another and peripheral members are connected to the core but not to each other. Mobilizing networks that have a core-periphery structure may be accomplished by focusing resources on the core members or by ensuring that the coremembers have sufficient resources or diversity to achieve network goals). For example, community coalitions are often composed of hundreds of organizations and/or individuals, yet the core working group may consist of no more than 20 organizations. Understanding who is part of this core and their distribution of assets is critical to coalition success.\n\nInduction. Induction interventions stimulate or force peer-to-peer interaction to create cascades in information/behavioral diffusion. Word-of-mouth (WOM) interventions stimulate interpersonal communication to persuade others to adopt the new behavior. Media marketing campaigns are often designed to generate buzz about their products, with the goal of increased sales, and frequently encourage users to recommend products to their friends and family. Often referred to as “going viral,” these interventions do not necessarily use network data, but they depend on the network for their effects. Research has shown that the success of WOM is a function of the network position of initial adopters and the incentives they have to recruit others. In respondent-driven sampling [(RDS), also known as “snowball methods”], individuals recruit others to participate in a study (for instance,a clinical trial) or receive an intervention. In RDS, an initial set of people who are members of the community or population to be influenced are selected and identified as “seeds.” These seeds then recruit members of their social networks who subsequently encourage additional people to participate, and so on. Researchers can use coupons or cards as a means to track who recruited whom. Additionally, researchers must decide on the number of seeds to start with and how many others each seed can be expected to recruit. RDS is quite effective at connecting with hard-to-reach individuals who might not otherwise receive services. This is achieved by initiating recruitment with people who are members of this marginalized group. One of the initial studies applying RDS to the recruitment of injection drug users (IDUs) showed that an unbiased sample of IDUs could be recruited within three to five waves of recruitment. This tactic enables researchers to generalize their study results to a broader group of IDUs and ensures that interventions for IDUs reach everyone they are intended to reach. Adhering consistently to study procedures and protocols over these three to five waves of data collection can be challenging, however. One participant generated more than 100 recruits of varying ethnicity, gender, and place of residence. RDS differs from WOM in that RDS interventions require the seeds to recruit their closely-associated peers, whereas WOM-interventions work by sparking interpersonal communication among any and all social ties. Network outreach is similar to RDS, except that the network seeds recruit members of their personal networks to participate in an intervention together, in which the behavior change messages can be delivered to the entire group. Network outreach is expected to be more effective than individual interventions because the motivations and lessons (such as preparation of healthy food) are delivered in a group context, and the group reinforces the positive behavior change.\n\nAlteration. Strategies one through three generally assume a static network (or ignore network dynamics). Many interventions deliberately alter the network to improve efficiency. Three different tactics might be considered: (i) adding/deleting nodes, (ii) adding/ deleting links, or (iii) rewiring existing links.\n\n\nAdding nodes is an important and long-standing behavior change approach with outside change agents, expert consultants, and lay health advisors (LHAs) being deployed in many settings to accelerate behavior change. Many studies have used LHAs, who are community members trained in behavior change techniques. These LHAs fan out into the community, often going from door to door, to inform individuals and groups about health and other topics to promote behavior change. LHAs may sometimes work within their existing social networks or approach strangers at their homes, places of business, or in public areas. Politicians and advocacy groups often mount “get out the vote” campaigns consisting of door-to-door appeals, which have been shown to increase voter participation and diffuse to other household members. Support groups, such as Alcoholics Anonymous, are often used to add new people to a person’s network to facilitate behavior change. Node-addition interventions often create connections randomly, yet it is probably preferable to add nodes to the network selectively on the basis of network position. New individuals should be added to a network to bridge disconnected or loosely connected groups.\nNode-deletion interventions remove nodes that occupy critical positions in a network. Nodes are then ranked on the degree to which their removal changes the network statistic. Node-deletion interventions have been embraced by antiterrorist agencies to degrade terrorist network organization. Removing critical nodes from sexual contact networks is an effective way for public health agencies to reduce disease spread and protect communities. In such cases, it is not always physical node removal but rather the use of protective behaviors (such as condom use) that inhibits transmission by the node. Node-deletion interventions change the focus of study from individual behavior to system dynamics in attempts to understand how communities or organizations respond to the removal or alteration of critical nodes.\nNetworks can be rewired to increase efficiency or improve performance based on certain goals. For example, teachers often randomize classroom networks so that ability levels are randomly distributed in the network. As with node and link changes, the researcher can also maximize the network on one or several metrics. Watts has suggested that optimal networks are those with short average distances between nodes and a high degree of clustering. These small-world networks maximize bridging and bonding opportunities in the network. Rewiring may be conducted to connect individuals with different attributes (e.g., a buddy system).\n\nSelecting an appropriate network intervention depends on many factors, including the type and character of available network data, the type of behavior change being promoted, and the environmental or situational context. Network data can be derived from many sources, including archived communications (such as phone, e-mail, text messaging, participant observations, published sources (such as corporate board membership), and survey data.\nAdvice networks identify people who are expert and credible sources of information and who usually have considerable technical knowledge about the idea or product. Discussion (and friendship) networks, in contrast, identify relations that are high in trust, mutual understanding, and interpersonal affect in which communication and persuasion flow easily. Discussion relations are mutual and close physically; advice relations are more likely to be asymmetric and distant.\nWhen barriers to adoption are technical or the innovation is complex, advice networks should be used for the intervention. In contrast,when barriers to adoption are primarily cultural, discussion networks may be more appropriate. Network interventions should measure different types of networks using the data for different strategies and tactics.\nGeographic distance also plays a role: Smaller, local organizations will generally rely on trusted peers for information and not depend on geographically distant leaders, because local leaders provide advice that is more sensitive to local conditions and culture. Geographically distant leaders are still quite important, however, and they might have more technical knowledge than local leaders, which would make them valued sources of information.\nIn addition to network type, overall network properties influence strategy selection. When network data indicate that the network is nonexistent, too fragmented, too centralized, or otherwise dysfunctional, there is a need for network change. The interventionist should use induction or alteration techniques to create a network amenable to change. Once the network is built or restructured, identification and segmentation tactics can be used to accelerate change. Network structure also matters. For example, a highly centralized network may profit from leader identification tactics, whereas a decentralized\nnetwork will not gain much from using leaders, and instead the analyst must rely on segmentation or induction strategies.\nCharacteristics of the behavior being studied also affect intervention choice. A program designed to spread information of a readily accepted idea can rely on easily identified opinion leaders, whereas one that requires complex organizational and personal changes may need dynamic rewiring and/or matching of change agents. Interdependent behaviors are those that increase in value as more people adopt them. For example, Facebook becomes more appealing as more of one’s friends use this social networking site. Interdependent behaviors often have slow initial uptake because there are few advantages to being an early adopter. Thus, interdependent innovations benefit from segmentation strategies, induction matching, or rewiring so that the interdependence can be explicitly addressed.\nPrevalence also affects intervention choice. At high levels of prevalence (greater than 75%), network interventions can be used to find individuals who have not yet adopted the behavior in question, perhaps due to their network position. At low prevalence (less than 15%), network interventions can identify whether early users are leaders and, thus, are well positioned to accelerate behavior spread or whether they are on the periphery and hence likely to be slowly imitated."
  },
  {
    "objectID": "5.html#simulating-network-diffusion-in-r",
    "href": "5.html#simulating-network-diffusion-in-r",
    "title": "\n6  Rationalization: Diffusion networks\n",
    "section": "\n6.2 Simulating network diffusion in R",
    "text": "6.2 Simulating network diffusion in R\nFor the analyses and simulation of diffusion processes, we rely on a package called netdiffuseR which includes built-in functions for simulating diffusion processes. Importantly, this package allows for consideration of both empirical and simulated networks as the starting point. The simulation is done in the following steps:\n\nUsing seed.graph, a baseline graph is created.\nGiven the baseline graph, the set of initial adopters is defined using seed.nodes.\nAfterwards, if rewire=TRUE t-1 slices of the network are created by iteratively rewiring the baseline graph.\nThe threshold.dist function is applied to each node in the graph.\nSimulation starts at t = 2 assigning adopters in each time period accordingly to each vertex’s threshold and exposure.\n\nThese are the main arguments of the function.\n\nn - The number of nodes to include in the network. This is only needed if a random graph is needed. If you supply a seed.graph (a real network) this argument is not needed.\nt - the number of time steps to consider.\nseed.graph - The argument seed.graph can be either a graph itself or a character scalar in which the user sets the algorithm used to generate the first network (network in t=1), this can be either “scale-free” (Barabasi-Albert model using the rgraph_ba function, the default), “bernoulli” (Erdos-Renyi model using the rgraph_er function), or “small-world” (Watts-Strogatz model using the rgraph_ws function). When you set an algorithm you need to provide arguments for the algorithm. The list rgraph.args' passes those arguments to the chosen algorithm (seergraph.ba,rgraph.ws, orrgraph.erin the manual). Thergraph.args’ is not needed when you work with an actual graph.\nseed.nodes - This argument can be set to either marginal, central, or random and this refers to the positions of the initial nodes to be “infected” or “adopters” in the network model. These options will select nodes with either the lowest degree, highest degree, or randomly respectively. Alternatively, you can supply a vector of node numbers representing the nodes which should be adopters in time step 1.\nseed.p.adopt - This is the proportion of nodes that will be initial adopters/infected.\nrewire - This logical argument expects a TRUE or FALSE. If TRUE at each time step a number of edges will be reassigned at random based on additional options passed to the rewire.args argument. Note that this argument is TRUE by default.\nthreshold.dist - This argument expects either a function or a vector of length n that defines the adoption threshold (susceptibility) of each node.\n\nAs we will see below, we do not need to use all of these arguments in every network simulation. Reading the documentation of the rdiffnet package provides additional details on options described briefly here.\nOne important concept that needs to be formally defined before we move on is the network threshold (defined in relationship to \\(\\tau\\) or threshold.dist). This is equal to the proportion of neighbors who need to be adopters for the target to adopt. So if \\(\\tau\\) equals .25, at least three out of four neighbors need to adopt before target adopts.\n\n6.2.1 random graph\nIn most applications this is randomly varied (like in the examples below), however it is possible to specify various thresholds for different actors.\n\nlibrary(netdiffuseR)\n\n\nAttaching package: 'netdiffuseR'\n\n\nThe following object is masked from 'package:dplyr':\n\n    recode\n\n\nThe following object is masked from 'package:base':\n\n    %*%\n\nset.seed(4436)\nnet_test1 &lt;- rdiffnet(\n  n = 1000,\n  t = 20,\n  seed.nodes = \"random\",\n  seed.p.adopt = 0.001,\n  seed.graph = \"small-world\",\n  rgraph.args = list(p = 0.1),\n  threshold.dist = function (x) runif(1, 0.1, 0.5)\n)\n\nWarning in (function (graph, p, algorithm = \"endpoints\", both.ends = FALSE, :\nThe option -copy.first- is set to TRUE. In this case, the first graph will be\ntreated as a baseline, and thus, networks after T=1 will be replaced with T-1.\n\nsummary(net_test1)\n\nDiffusion network summary statistics\nName     : A diffusion network\nBehavior : Random contagion\n-----------------------------------------------------------------------------\n Period   Adopters   Cum Adopt. (%)   Hazard Rate   Density   Moran's I (sd)  \n-------- ---------- ---------------- ------------- --------- ---------------- \n       1          1         1 (0.00)             -      0.00 -0.00 (0.00)     \n       2          4         5 (0.00)          0.00      0.00  0.10 (0.01) *** \n       3          6        11 (0.01)          0.01      0.00  0.16 (0.01) *** \n       4          9        20 (0.02)          0.01      0.00  0.18 (0.01) *** \n       5         13        33 (0.03)          0.01      0.00  0.18 (0.01) *** \n       6         25        58 (0.06)          0.03      0.00  0.20 (0.01) *** \n       7         39        97 (0.10)          0.04      0.00  0.24 (0.01) *** \n       8         71       168 (0.17)          0.08      0.00  0.19 (0.01) *** \n       9        124       292 (0.29)          0.15      0.00  0.20 (0.01) *** \n      10        167       459 (0.46)          0.24      0.00  0.21 (0.01) *** \n      11        197       656 (0.66)          0.36      0.00  0.18 (0.01) *** \n      12        186       842 (0.84)          0.54      0.00  0.16 (0.01) *** \n      13        111       953 (0.95)          0.70      0.00  0.10 (0.01) *** \n      14         41       994 (0.99)          0.87      0.00  0.03 (0.01) *** \n      15          6      1000 (1.00)          1.00      0.00               -  \n      16          0      1000 (1.00)          0.00      0.00               -  \n      17          0      1000 (1.00)          0.00      0.00               -  \n      18          0      1000 (1.00)          0.00      0.00               -  \n      19          0      1000 (1.00)          0.00      0.00               -  \n      20          0      1000 (1.00)          0.00      0.00               -  \n-----------------------------------------------------------------------------\n Left censoring  : 0.00 (1)\n Right centoring : 0.00 (0)\n # of nodes      : 1000\n\n Moran's I was computed on contemporaneous autocorrelation using 1/geodesic\n values. Significane levels  *** &lt;= .01, ** &lt;= .05, * &lt;= .1.\n\n\nIn this example, we have created a random network with 1000 nodes and small world structure. We examine the network across 20 time steps. We send a value of 0.1 to the rgraph.args argument meaning that proportion of ties will be rewired in the random graph to generate “small-world” structure (see rgaph_ws for more info) in the initial network configuration. We set the initial adopters in the network to 0.001 or a single node in this 1000 node network. Finally, we set the threshold.dist to be a random uniform number (using the runif function) between 0.1 and 0.5 meaning that a node will adopt the contagion at a given time step if between 10% and 50% of it’s neighbors have adopted. Note that we have not set a value for rewire so by default this is TRUE and a small proportion of edges will be rewired at each time step.\nThe summary output provides information on the number of adopters and the cumulative adoption percent at each time step. We also have information on the hazard rate, which is the probability that a given node will be infected/adopt at each step.\nThe Moran’s I is a measure of autocorrelation which here is sued to indicate whether infected nodes/adopters are concentrated among neighbors in the network (nodes that share an edge). Not surprisingly, we see they are across all but the first time step. Moran's I is not exam material, no need to memorize this.\nThe netdiffuseR package also has built in functions for plotting. First, let’s plot our simulated network at a few different time steps to see the distributions of adopters and non-adopters. Here we plot the 1st, 10th, and 15th time steps:\n\nplot_diffnet(net_test1, slices = c(1, 10, 15))\n\n\n\n\n\nplot_adopters(net_test1)\n\n\n\n\nWe can also plot a network that shows the time step at which each node adopted the contagion:\n\nplot_diffnet2(net_test1)"
  },
  {
    "objectID": "5.html#simulating-diffussion-in-an-actual-network",
    "href": "5.html#simulating-diffussion-in-an-actual-network",
    "title": "\n6  Rationalization: Diffusion networks\n",
    "section": "\n6.3 Simulating diffussion in an actual network",
    "text": "6.3 Simulating diffussion in an actual network\nThe above example is a pure simulation, with a random graph as the starting point. rdiffnet allows us to use a real world network to simulate a diffusion process. For our purposes this is more interesting. Reading the data has been discussed before and is straightforward. We use the (symmetrized) data that we used to discuss visualization earlier in the course (organizational network of 21 managers). We focus on information exchange relationships (one or both of the actors in a relation provides the other with advice).\n\nInitial.matrix &lt;- read.csv(\"data/Krack-High-Tec-Advise-edges.csv\", header=TRUE, row.names=1, check.names=FALSE, na.strings = \"\")\nmatrix &lt;- as.matrix(Initial.matrix) \n#symmetrize the matrix\nmatrix=matrix+t(matrix)\nmatrix[matrix==2]&lt;-1\nnodes &lt;- read.csv(file = \"data/Krackh-High-Tec-nodes2.csv\", sep = \";\", header=TRUE)\n\nWe can now use the adjacency matrix as the seed graph (after symmetrizing). Again the thresholds are random. To help interpret the visualization of the diffusion process, we use the names of the managers as provided in the nodes file.\n\nn=nodes$names\nset.seed(4436)\nnet_test2 &lt;- rdiffnet(\n  t = 10,\n  seed.nodes = \"random\",\n  seed.p.adopt = 0.1,\n  seed.graph = matrix,\n  rewire=FALSE,\n  threshold.dist = function (x) runif(1, 0.1, 0.2)\n)\n\nsummary(net_test2)\n\nDiffusion network summary statistics\nName     : A diffusion network\nBehavior : Random contagion\n-----------------------------------------------------------------------------\n Period   Adopters   Cum Adopt. (%)   Hazard Rate   Density   Moran's I (sd)  \n-------- ---------- ---------------- ------------- --------- ---------------- \n       1          2         2 (0.10)             -      0.69 -0.06 (0.01)     \n       2          2         4 (0.19)          0.11      0.69 -0.04 (0.02)     \n       3         14        18 (0.86)          0.82      0.69 -0.03 (0.02)     \n       4          3        21 (1.00)          1.00      0.69               -  \n       5          0        21 (1.00)          0.00      0.69               -  \n       6          0        21 (1.00)          0.00      0.69               -  \n       7          0        21 (1.00)          0.00      0.69               -  \n       8          0        21 (1.00)          0.00      0.69               -  \n       9          0        21 (1.00)          0.00      0.69               -  \n      10          0        21 (1.00)          0.00      0.69               -  \n-----------------------------------------------------------------------------\n Left censoring  : 0.10 (2)\n Right centoring : 0.00 (0)\n # of nodes      : 21\n\n Moran's I was computed on contemporaneous autocorrelation using 1/geodesic\n values. Significane levels  *** &lt;= .01, ** &lt;= .05, * &lt;= .1.\n\nplot_diffnet(net_test2, slices = c(1, 2, 3), vertex.label=n)\n\n\n\nplot_diffnet(net_test2, slices = c(4, 5, 6), vertex.label=n)\n\n\n\n\nThe selection of early adopters (nodes that are first to adopt the innovation) is random in this simulation. So is the selection of thresholds. A threshold of 1 in the model implies that an actor only then adopts if 100% of the neighbors adopt as well. In the continuation we select two actors who start the diffusion process. We also assume that older employees are less innovative, so the treshold is not random anymore.\n\n# we must ensure that the thresholds (based on age) are between 0 (% neighbors #needed to adopt) and 1 (all neighbors must adopt before actor adopts)\n\nage=nodes$AGE\nage&lt;-age/max(age)\nage&lt;-age-min(age)\nage\n\n [1] 0.09677419 0.24193548 0.20967742 0.09677419 0.08064516 0.51612903\n [7] 0.45161290 0.11290323 0.56451613 0.16129032 0.30645161 0.11290323\n[13] 0.33870968 0.25806452 0.20967742 0.00000000 0.04838710 0.09677419\n[19] 0.08064516 0.17741935 0.14516129\n\nset.seed(4436)\nnet_test2 &lt;- rdiffnet(\n  t = 10,\n  seed.nodes = c(1,18),\n  seed.graph = matrix,\n  rewire=FALSE,\n  threshold.dist = age)\n\nsummary(net_test2)\n\nDiffusion network summary statistics\nName     : A diffusion network\nBehavior : Random contagion\n-----------------------------------------------------------------------------\n Period   Adopters   Cum Adopt. (%)   Hazard Rate   Density   Moran's I (sd)  \n-------- ---------- ---------------- ------------- --------- ---------------- \n       1          2         2 (0.10)             -      0.69 -0.05 (0.01)     \n       2          6         8 (0.38)          0.32      0.69 -0.04 (0.02)     \n       3         10        18 (0.86)          0.77      0.69 -0.02 (0.02) *   \n       4          3        21 (1.00)          1.00      0.69               -  \n       5          0        21 (1.00)          0.00      0.69               -  \n       6          0        21 (1.00)          0.00      0.69               -  \n       7          0        21 (1.00)          0.00      0.69               -  \n       8          0        21 (1.00)          0.00      0.69               -  \n       9          0        21 (1.00)          0.00      0.69               -  \n      10          0        21 (1.00)          0.00      0.69               -  \n-----------------------------------------------------------------------------\n Left censoring  : 0.10 (2)\n Right centoring : 0.00 (0)\n # of nodes      : 21\n\n Moran's I was computed on contemporaneous autocorrelation using 1/geodesic\n values. Significane levels  *** &lt;= .01, ** &lt;= .05, * &lt;= .1.\n\nplot_diffnet(net_test2, slices = c(1, 2, 3), vertex.label=n)\n\n\n\nplot_diffnet(net_test2, slices = c(4, 5, 6), vertex.label=n)\n\n\n\nplot_adopters(net_test2)\n\n\n\n\nAnd we can plot a network that shows the time step at which each node adopted the contagion, although since the process was quick the plot is not that clear:\n\nplot_diffnet2(net_test2)"
  },
  {
    "objectID": "5.html#exercise",
    "href": "5.html#exercise",
    "title": "\n6  Rationalization: Diffusion networks\n",
    "section": "\n6.4 Exercise",
    "text": "6.4 Exercise\n\nUsing the rdiffnet function compare a diffusion process in two random networks (n=100, t=20). Explore whether it matters when you select marginal or central early adopters.\nUse the friendship network of the Krackhardt data “Krack-High-Tec-Friendship-edges.csv”. Select two central nodes as early adopters, then select two marginal nodes, compare the results of the network diffusion simulation.\nUsing the same model as in question 2, repeat the analysis but assume that threshold depends on tenure."
  }
]